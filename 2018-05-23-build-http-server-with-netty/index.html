

<!DOCTYPE html>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <title>使用Netty构建Http容器 [ Sincerity ]</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="icon" href="/images/favicon-32x32.png">
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/simple.css">
  
  <link rel="stylesheet" href="/css/font.css">
  
  
</head>

<body>

  <header class="header">
    <nav class="nav">
      <a href="/" class="nav-logo"><img src="/images/avatar.png" width="50" height="50" alt="Logo"></a>
      <ul class="nav-links">
        
        <li><a href="/">文章列表</a></li>
        
        <li><a href="/archives">归档</a></li>
        
        <li><a href="/leetcode">力扣</a></li>
        
        <li><a href="/about">关于我</a></li>
        
        <li><a href="https://github.com/calebman">Github</a></li>
        
      </ul>
    </nav>
  </header>

  <main class="content">
    <article class="article">
  <h1 class="article-title">使用Netty构建Http容器</h1>
  <span class="article-date">2018-05-23</span>
  
  
  <a class="article-tag" href="/tags/Spring">
    Spring
  </a>
  
  <a class="article-tag" href="/tags/Netty">
    Netty
  </a>
  
  

  <div class="article-content">
    <p>使用Netty构建一个SpringBoot风格的Web框架</p>
<a id="more"></a>

<h3 id="要实现怎样的效果"><a href="#要实现怎样的效果" class="headerlink" title="要实现怎样的效果"></a>要实现怎样的效果</h3><blockquote>
<p>一个SpringBoot框架搭建起来的项目发布接口服务是这样的</p>
<p>SpringBoot搭建教程<strong><a href="/2018-02-21-build-springboot-env/">点击这里</a></strong></p>
</blockquote>
<pre><code class="java">@Controller
@RequestMapping(&quot;/v1/product&quot;)
public class DocController {

    @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET)
    @ResponseBody
    public WebResult search(@PathVariable(&quot;id&quot;) Integer id) {
        logger.debug(&quot;获取指定产品接收产品id=&gt;%d&quot;, id);
        if (id == null || &quot;&quot;.equals(id)) {
            logger.debug(&quot;产品id不能为空&quot;);
            return WebResult.error(ERRORDetail.RC_0101001);
        }
        return WebResult.success(products.get(id));
    }
}</code></pre>
<blockquote>
<p>我希望我使用Netty构建的Web服务器也能使用这样便捷的注解方式去发布我的接口服务</p>
</blockquote>
<h3 id="该怎么做"><a href="#该怎么做" class="headerlink" title="该怎么做"></a>该怎么做</h3><p><img src="https://resources.chenjianhui.site/2018-05-23-xmind-brain-map.png" alt="系统流程"></p>
<ul>
<li>使用Netty自带的编解码、聚合器构建一个带有Http编解码功能的服务器这一点其实非常简单，Netty提供了对应的Http协议的编解码以及聚合器，我们只需要在管道初始化的时候加载它们。</li>
</ul>
<pre><code class="java">public class HttpPipelineInitializer extends ChannelInitializer&lt;Channel&gt; {
    //编解码处理器名称
    public final static String CODEC = &quot;codec&quot;;
    //HTTP消息聚合处理器名称
    public final static String AGGEGATOR = &quot;aggegator&quot;;
    //HTTP消息压缩处理器名称
    public final static String COMPRESSOR = &quot;compressor&quot;;

    @Override
    protected void initChannel(Channel channel) throws Exception {
        ChannelPipeline pipeline = channel.pipeline();
        pipeline.addLast(CODEC, new HttpServerCodec());
        pipeline.addLast(AGGEGATOR, new HttpObjectAggregator(512 * 1024));
        pipeline.addLast(COMPRESSOR,new HttpContentCompressor());
        pipeline.addLast(new AllocHandler());
    }
}</code></pre>
<ul>
<li>实现RequestMapping注解，用于标识处理器或者控制器对应匹配的接口地址。</li>
</ul>
<pre><code class="java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequestMapping {
    String[] value() default {};
}</code></pre>
<ul>
<li>提供启动入口，程序启动时创建Spring容器，并基于Spring初始化必要组件</li>
</ul>
<ol>
<li>提供程序入口类</li>
</ol>
<pre><code class="java">public class CettyBootstrap {
    private static final Logger logger = LoggerFactory.getLogger(CettyBootstrap.class);
    private static final String DEFAULT_SPRING_XMLPATH = &quot;classpath:applicantContext.xml&quot;;
    private static final String DEFAULT_HTTP_SERVER_BEAN_NAME = &quot;defaultHttpServer&quot;;

    public static void create() {
        create(DEFAULT_SPRING_XMLPATH);
    }

    public static void create(String springXmlpath) {
        if (StringUtils.isEmpty(springXmlpath)) {
            springXmlpath = DEFAULT_SPRING_XMLPATH;
        }
        logger.debug(&quot;spring框架配置文件地址为{}&quot;, springXmlpath);
        try {
            ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(springXmlpath.split(&quot;[,\\s]+&quot;));
            context.start();
            logger.debug(&quot;spring框架启动成功&quot;);
            try {
                context.getBean(DEFAULT_HTTP_SERVER_BEAN_NAME, DefaultHttpServer.class);
            } catch (NoSuchBeanDefinitionException ex) {
                logger.warn(&quot;未配置HttpServer，采用默认配置启动&quot;);
                context.getAutowireCapableBeanFactory().createBean(DefaultHttpServer.class);
            }
        } catch (BeansException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<ol start="2">
<li>定义默认实现的HttpServer组件，随Spring容器启动时加载基于Netty的Web容器，并使用HandlerMapping组件初始化HttpPipelineInitializer管道，其中HandlerMapping如果未有用户定义则使用默认的DefaultHandlerMapping实现</li>
</ol>
<pre><code class="java">public class DefaultHttpServer extends ApplicationObjectSupport {
    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpServer.class);
    private static final String DEFAULT_HTTP_PORT = &quot;8080&quot;;
    private static final String HANDLER_MAPPING_BEAN_NAME = &quot;handlerMapping&quot;;


    private String port;

    private HandlerMapping handlerMapping;

    public void setPort(String port) {
        this.port = port;
    }

    @Override
    public void initApplicationContext(ApplicationContext applicationContext) {
        beforeInit(applicationContext);
        initHandlerMapping(applicationContext);
        initServer();
    }

    void initHandlerMapping(ApplicationContext context) {
        try {
            this.handlerMapping = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
        } catch (NoSuchBeanDefinitionException ex) {
            this.handlerMapping = context.getAutowireCapableBeanFactory().createBean(DefaultHandlerMapping.class);
        }
    }

    void initServer() {
        logger.debug(&quot;初始化服务器&quot;);
        if (!HttpUtils.isPort(port)) {
            logger.warn(&quot;端口号不合法，使用默认端口{}&quot;, DEFAULT_HTTP_PORT);
            port = DEFAULT_HTTP_PORT;
        }
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .localAddress(new InetSocketAddress(Integer.parseInt(port)))
                    .childHandler(new HttpPipelineInitializer(handlerMapping));

            ChannelFuture f = b.bind().sync();
            logger.info(&quot;服务启动成功，监听{}端口&quot;, port);
            f.channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            try {
                workerGroup.shutdownGracefully().sync();
                bossGroup.shutdownGracefully().sync();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    protected void beforeInit(ApplicationContext applicationContext) {

    }

}</code></pre>
<ol start="3">
<li>提供默认的HandlerMapping实现类，负责匹配@RequestMapping注解下的处理函数</li>
</ol>
<pre><code class="java">public class DefaultHandlerMapping extends ApplicationObjectSupport implements HandlerMapping {
    Logger logger = LoggerFactory.getLogger(DefaultHandlerMapping.class);

    private static Map&lt;String, HttpHandler&gt; httpHandlerMap = new HashMap&lt;String, HttpHandler&gt;();

    @Override
    public void initApplicationContext(ApplicationContext context) throws BeansException {
        logger.debug(&quot;初始化处理匹配器&quot;);
        Map&lt;String, Object&gt; handles = context.getBeansWithAnnotation(Controller.class);
        try {
            for (Map.Entry&lt;String, Object&gt; entry : handles.entrySet()) {
                logger.debug(&quot;加载控制器{}&quot;, entry.getKey());
                loadHttpHandler(entry.getValue());
            }
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        }
    }

    void loadHttpHandler(Object value) throws IllegalAccessException, InstantiationException {
        Class clazz = value.getClass();
        Object clazzFromInstance = clazz.newInstance();
        Method[] method = clazz.getDeclaredMethods();
        for (Method m : method) {
            if (m.isAnnotationPresent(RequestMapping.class)) {
                RequestMapping requestMapping = m.getAnnotation(RequestMapping.class);
                for (String url : requestMapping.value()) {
                    HttpHandler httpHandler = httpHandlerMap.get(url);
                    if (httpHandler == null) {
                        logger.info(&quot;加载url为{}的处理器{}&quot;, url, m.getName());
                        httpHandlerMap.put(url, new HttpHandler(clazzFromInstance, m));
                    } else {
                        logger.warn(&quot;url{}存在相同的处理器&quot;, url);
                    }
                }
            }
        }
    }

    @Override
    public HttpHandler getHadnler(FullHttpRequest request) {
        return httpHandlerMap.get(request.uri());
    }
}</code></pre>
<ul>
<li>当请求进入时通过HandlerMapping组件匹配处理器，如果匹配失败则返回404</li>
</ul>
<pre><code class="java">public class AllocHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; {

    private HandlerMapping handlerMapping;

    public AllocHandler(HandlerMapping handlerMapping) {
        this.handlerMapping = handlerMapping;
    }

    /*
    异常处理
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        sendError(ctx, HttpResponseStatus.INTERNAL_SERVER_ERROR);
        super.exceptionCaught(ctx, cause);
    }

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest fullHttpRequest) throws Exception {
        HttpHandler httpHandler = handlerMapping.getHadnler(fullHttpRequest);
        if (httpHandler != null) {
            Object obj = httpHandler.execute(fullHttpRequest);
            if (obj instanceof String) {
                sendMessage(ctx, obj.toString());
            } else {
                sendMessage(ctx, JSONObject.toJSONString(obj));
            }
        } else {
            sendError(ctx, HttpResponseStatus.NOT_FOUND);
        }
    }

    private void sendMessage(ChannelHandlerContext ctx, String msg) {
        FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8));
        response.headers().set(&quot;Content-Type&quot;, &quot;text/plain&quot;);
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    }

    private void sendError(ChannelHandlerContext ctx, HttpResponseStatus httpResponseStatus) {
        FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, httpResponseStatus, Unpooled.copiedBuffer(httpResponseStatus.toString(), CharsetUtil.UTF_8));
        response.headers().set(&quot;Content-Type&quot;, &quot;text/plain&quot;);
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    }
}</code></pre>
<h3 id="测试与使用"><a href="#测试与使用" class="headerlink" title="测试与使用"></a>测试与使用</h3><ul>
<li>建立一个TestController</li>
</ul>
<pre><code class="java">@Controller
public class TestController {

    @RequestMapping(&quot;/test&quot;)
    public String testHandler(FullHttpRequest fullHttpRequest) {
        return &quot;1234&quot;;
    }

    @RequestMapping(&quot;/zx&quot;)
    public String zx(FullHttpRequest fullHttpRequest) {
        return &quot;zhuxiong&quot;;
    }

    @RequestMapping(&quot;/obj&quot;)
    public Object obj(FullHttpRequest fullHttpRequest) {
        System.out.println(&quot;\n\n----------&quot;);
        HttpHeaders httpHeaders = fullHttpRequest.headers();
        Set&lt;String&gt; names = httpHeaders.names();
        for (String name : names) {
            System.out.println(name + &quot; : &quot; + httpHeaders.get(name));
        }
        System.out.println(&quot;&quot;);
        ByteBuf byteBuf = fullHttpRequest.content();
        byte[] byteArray = new byte[byteBuf.capacity()];
        byteBuf.readBytes(byteArray);
        System.out.println(new String(byteArray));
        System.out.println(&quot;----------\n\n&quot;);

        JSONObject json = new JSONObject();
        json.put(&quot;errCode&quot;, &quot;00&quot;);
        json.put(&quot;errMsg&quot;, &quot;0000000(成功)&quot;);
        json.put(&quot;data&quot;, null);
        return json;
    }
}</code></pre>
<ul>
<li>启动Spring容器</li>
</ul>
<pre><code class="java">public class HttpServerTest {
    public static void main(String[] args) throws Exception {
        CettyBootstrap.create();
        // CettyBootstrap.create(&quot;classpath:applicationContext.xml&quot;);
    }
}</code></pre>
<h3 id="未来要做的"><a href="#未来要做的" class="headerlink" title="未来要做的"></a>未来要做的</h3><ul>
<li><input checked disabled type="checkbox"> 与Spring框架集成，将核心组件托管给Spring容器统一管理</li>
<li><input disabled type="checkbox"> 提供静态资源映射</li>
<li><input disabled type="checkbox"> 修改映射策略将请求映射至一个流程（一个处理器多个拦截器）</li>
<li><input disabled type="checkbox"> 支持使用模板语法进行视图解析</li>
</ul>

  </div>
</article>
<ul class="post-copyright">
  <li><strong>本文标题：</strong><a href="https://chenjianhui.site/2018-05-23-build-http-server-with-netty/">使用Netty构建Http容器</a></li>
  <li><strong>本文作者：</strong><a href="https://chenjianhui.site">JianhuiChen</a></li>
  <li><strong>本文链接：</strong><a href="https://chenjianhui.site/2018-05-23-build-http-server-with-netty/">https://chenjianhui.site/2018-05-23-build-http-server-with-netty/</a></li>
  <li><strong>发布时间：</strong>2018-05-23</li>
  <li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>
<div id="gitalk-container"></div>

<!-- Gittalk.js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- Highlight.js -->
<link rel="stylesheet" href="/css/hljs.css">
<script src="/js/highlight.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  const gitalk = new Gitalk({
    clientID: 'bd0cbb30da9c24da8c7c',
    clientSecret: 'bd64a8e8c8117d5f3e22291cd3f29f2c70e671ff',
    repo: 'blog',
    owner: 'calebman',
    admin: ['calebman']
  })
  gitalk.render('gitalk-container')
</script>
  </main>

  <footer class="footer">
    <ul class="footer-links">
      <section class="copyright">
        <a href="https://chenjianhui.site">JianhuiChen</a> © 2017 - 2020 | 
        <a href="http://www.beian.miit.gov.cn" style="line-height: 37px;font-size: 16px;">津ICP备19001724号</a>
      </section>
    </ul>
  </footer>

  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/simple.js"></script>
  
  

</body>

</html>