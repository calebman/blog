

<!DOCTYPE html>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <title>算法——24点游戏 [ Sincerity ]</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="icon" href="/images/favicon-32x32.png">
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/simple.css">
  
  <link rel="stylesheet" href="/css/font.css">
  
  
</head>

<body>

  <header class="header">
    <nav class="nav">
      <a href="/" class="nav-logo"><img src="/images/avatar.png" width="50" height="50" alt="Logo"></a>
      <ul class="nav-links">
        
        <li><a href="/">文章列表</a></li>
        
        <li><a href="/archives">归档</a></li>
        
        <li><a href="/leetcode">力扣</a></li>
        
        <li><a href="/about">关于我</a></li>
        
        <li><a href="https://github.com/calebman">Github</a></li>
        
      </ul>
    </nav>
  </header>

  <main class="content">
    <article class="article">
  <h1 class="article-title">算法——24点游戏</h1>
  <span class="article-date">2019-06-17</span>
  
  
  <a class="article-tag" href="/tags/Algorithm">
    Algorithm
  </a>
  
  <a class="article-tag" href="/tags/Java">
    Java
  </a>
  
  

  <div class="article-content">
    <p>  给定四个1-10的正整数，可以进行+ - * / 四种运算，每个数字只能用一次，任意组合构造表达式使结果为24，要找出所有可能的组合？</p>
<a id="more"></a>
<h1>解题思考</h1>
<p>  初拿到题目最先想到的就是穷举法了，我们先假设四个数字为A、B、C、D，然后穷举所有的可能性，简单算一下可以得到一共有<strong>4! * 4^3 = 1536</strong>种可能性，如下图所示：</p>
<p><img src="https://resources.chenjianhui.site/2019-06-17-24game-tree.jpg" alt></p>
<h1>DFS解法</h1>
<p>  DFS是<strong>Depth-First search 深度优先搜索</strong>的简称，与其对应的还有BFS(<strong>Breadth-First-Search 广度优先搜索</strong>)，在这里我们使用递归的方式深度优先遍历搜索树找到所有可能性，然后根据得出的算术表达式（如1+2+3*4）计算并判断筛选出计算结果为24的组合，代码如下：</p>
<pre><code class="language-java">import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * @author JianhuiChen
 * @description 24点游戏
 * @date 2019/6/18
 */
public class Count24 {

    public static void main(String[] args) {
        List&lt;String&gt; results = permutation(Arrays.asList(1, 2, 3, 4),
                Arrays.asList(Operator.PLUS, Operator.MINUS, Operator.MULTIPLY, Operator.DIVIDE));
        results.stream()
                .filter(express -&gt; expectCalc(express, 24))
                .forEach(System.out::println);
    }


    private static List&lt;String&gt; permutation(List&lt;Integer&gt; numbers, List&lt;Operator&gt; operators) {
        return permutation(numbers, operators, null);
    }

    /**
     * 深度优先搜索策略得出所有的组合可能性
     *
     * @param numbers       参与选择的数字
     * @param operators     参与运算的运算符
     * @param expressRecord 算术表达式记录值
     * @return 可能性组合
     */
    private static List&lt;String&gt; permutation(List&lt;Integer&gt; numbers, List&lt;Operator&gt; operators, String expressRecord) {
        if (expressRecord == null) {
            expressRecord = &quot;&quot;;
        }
        List&lt;String&gt; resultList = new ArrayList&lt;&gt;();
        for (int num : numbers) {
            if (numbers.size() == 1) {
                // 只剩一个数字未选时退出循环
                resultList.add(expressRecord + num);
                break;
            }
            for (Operator oper : operators) {
                // 过滤掉已选项
                List&lt;Integer&gt; optional = numbers.stream()
                        .filter(n -&gt; n != num)
                        .collect(Collectors.toList());
                resultList.addAll(permutation(optional, operators, expressRecord + num + oper));
            }
        }
        return resultList;
    }

    /**
     * 进行预期运算
     *
     * @param aritExpression 算术表达式
     * @param targetVal      目标值
     * @return 是否符合预期
     */
    private static boolean expectCalc(String aritExpression, int targetVal) {
        return calculation(aritExpression) == targetVal;
    }


    /**
     * 根据算术表达式求值
     *
     * @param aritExpression 算术表达式 exp: 4*2/1*3
     * @return 计算结果
     */
    private static int calculation(String aritExpression) {
        // 将表达式根据运算符切割
        StringTokenizer tokenizer = new StringTokenizer(aritExpression, &quot;+-*/&quot;, true);
        Stack&lt;Double&gt; numStack = new Stack&lt;&gt;();   // 存放数字
        Stack&lt;Operator&gt; operStack = new Stack&lt;&gt;();  // 存放操作符
        String currentEle;  // 当前元素
        while (tokenizer.hasMoreTokens()) {
            currentEle = tokenizer.nextToken().trim();  // 去掉前后的空格
            if (!&quot;&quot;.equals(currentEle)) {   // 只处理非空字符
                if (Pattern.matches(&quot;^\\d+(\\.\\d+)?$&quot;, currentEle)) { // 为数字时则加入到数字栈中
                    numStack.push(Double.valueOf(currentEle));
                } else {
                    Operator currentOper = Operator.getOperatorBySymbol(currentEle);//获取当前运算操作符
                    if (currentOper == null) {
                        throw new RuntimeException(&quot;存在无效的操作符&quot; + currentEle);
                    }
                    while (!operStack.empty() &amp;&amp; operStack.peek().priority() &gt;= currentOper.priority()) {
                        compute(numStack, operStack);
                    }
                    // 计算完后把当前操作符加入到操作栈中
                    operStack.push(currentOper);
                }
            }
        }
        // 经过上面代码的遍历后最后的应该是nums里面剩两个数或三个数，operators里面剩一个或两个运算操作符
        while (!operStack.empty()) {
            compute(numStack, operStack);
        }
        return numStack.pop().intValue();
    }

    /**
     * 取numStack的最顶上两个数字
     * operStack的最顶上一个运算符进行运算
     * 然后把运算结果再放到numStack的最顶端
     *
     * @param numStack  数字栈
     * @param operStack 操作栈
     */
    private static void compute(Stack&lt;Double&gt; numStack, Stack&lt;Operator&gt; operStack) {
        Double num2 = numStack.pop(); // 弹出数字栈最顶上的数字作为运算的第二个数字
        Double num1 = numStack.pop(); // 弹出数字栈最顶上的数字作为运算的第一个数字
        Double computeResult = operStack.pop().compute(num1, num2); // 弹出操作栈最顶上的运算符进行计算
        numStack.push(computeResult); // 把计算结果重新放到队列的末端
    }


    /**
     * 支持的运算符
     */
    private enum Operator {
        PLUS(&quot;+&quot;) {
            @Override
            public int priority() {
                return 1;
            }

            @Override
            public double compute(double a, double b) {
                return a + b;
            }
        },
        MINUS(&quot;-&quot;) {
            @Override
            public int priority() {
                return 1;
            }

            @Override
            public double compute(double a, double b) {
                return a - b;
            }
        },
        MULTIPLY(&quot;*&quot;) {
            @Override
            public int priority() {
                return 2;
            }

            @Override
            public double compute(double a, double b) {
                return a * b;
            }
        },
        DIVIDE(&quot;/&quot;) {
            @Override
            public int priority() {
                return 2;
            }

            @Override
            public double compute(double a, double b) {
                return a / b;
            }
        };

        Operator(String symbol) {
            this.symbol = symbol;
        }

        /**
         * 运算符
         */
        private String symbol;

        /**
         * @return 运算优先级
         */
        public abstract int priority();

        /**
         * @param a 第一个运算数
         * @param b 第二个运算数
         * @return 两个数对应的运算结果
         */
        public abstract double compute(double a, double b);

        /**
         * 根据运算符查找运算操作类
         *
         * @param symbol 运算符
         * @return 运算操作类
         */
        public static Operator getOperatorBySymbol(String symbol) {
            for (Operator operator : Operator.values()) {
                if (symbol.equals(operator.toString())) {
                    return operator;
                }
            }
            return null;
        }


        @Override
        public String toString() {
            return symbol;
        }
    }
}
</code></pre>
<p>  输入<code>2、4、6、8</code>能得到以下部分结果</p>
<pre><code>2*6+4+8
2*6+8+4
2*6*8/4
2*6/4*8
2*8*6/4
2*8/4*6
2/4*6*8
2/4*8*6
2/8+4*6
2/8+6*4
4+2*6+8
4+6*2+8
4+8+2*6
4+8+6*2
4*6+2/8
4*8-2-6
...
</code></pre>
<h1>优化思路</h1>
<p>  上述算法做了很多的重复计算，众所周知，加法和乘法是满足交换律的，所以如<code>1*2*3*4</code>这类组合任意排列所得的计算结果都是相同的，针对这部分我们可以如<a href="/2019-06-13-algorithm-topic/">爬楼梯问题的备忘录算法</a>缓存计算结果，防止重复计算。</p>
<h1>题目拓展，添加优先级</h1>
<p>  我们简单的将上述的24点游戏扩展一下，除了数字和运算符我们再加上括号的选择，这个时候有多少种情况？代码该如何变更？其实简单想想加上括号即让任意组合如ABCD又演变出了五种加括号的方式<code>((AB)C)D、(A(BC))D、(AB)(CD)、A(((BC)D)、A(B(CD))</code>，然后根据括号运算搜索出正确答案即可，有兴趣的同学可以修改上述代码完成该题。</p>

  </div>
</article>
<ul class="post-copyright">
  <li><strong>本文标题：</strong><a href="https://chenjianhui.site/2019-06-17-algorithm-topic/">算法——24点游戏</a></li>
  <li><strong>本文作者：</strong><a href="https://chenjianhui.site">JianhuiChen</a></li>
  <li><strong>本文链接：</strong><a href="https://chenjianhui.site/2019-06-17-algorithm-topic/">https://chenjianhui.site/2019-06-17-algorithm-topic/</a></li>
  <li><strong>发布时间：</strong>2019-06-17</li>
  <li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>
<div id="gitalk-container"></div>

<!-- Gittalk.js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- Highlight.js -->
<link rel="stylesheet" href="/css/hljs.css">
<script src="/js/highlight.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  const gitalk = new Gitalk({
    clientID: 'bd0cbb30da9c24da8c7c',
    clientSecret: 'bd64a8e8c8117d5f3e22291cd3f29f2c70e671ff',
    repo: 'blog',
    owner: 'calebman',
    admin: ['calebman']
  })
  gitalk.render('gitalk-container')
</script>
  </main>

  <footer class="footer">
    <ul class="footer-links">
      <section class="copyright">
        <a href="https://chenjianhui.site">JianhuiChen</a> © 2017 - 2020 | 
        <a href="http://www.beian.miit.gov.cn" style="line-height: 37px;font-size: 16px;">津ICP备19001724号</a>
      </section>
    </ul>
  </footer>

  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/simple.js"></script>
  
  

</body>

</html>