{"pages":[{"title":"","text":"","link":"/leetcode/index.html"},{"title":"关于我","text":"我是谁程序员一枚，喜爱熟悉的不熟悉的技术，掌握各种技术名称的拼写，尤其是Vuejs与Java。 联系方式 WeChat: Nc_Nobbdy Mail: chenjianhui@gmail.com Github: https://github.com/calebman Blog: https://chenjianhui.site QQ: 675557552 不咋用就是 个人经历17年毕业于@南昌航空大学，现划水于天津 兴趣爱好 如果有一天是周末，事情的优先级从高到低排序大概是这样的 陪女盆友（这很重要） 加班？（如果需要的话） 和男盆友打dota（别说教女盆友打dota这就两全了，这属于坑自己🐶） 刷刷技术博客、开源项目（提升写作能力） 维护自己的项目、写博客（有这项爱好已经很不容易了，还管排在第几？） 会打篮球、羽毛球之类的（如果有人一起打的话，现实是没有😢） 对自己的期望在大学的时候甘老师跟我说过一句话 你看过不代表你会了，你写过不代表你会了，你能教给别人才代表你会了。 到现在为止一年多坚持写博客的经历让我认识到这句话，一个系统的知识由很多碎片化的知识点组成，模拟教学思维能够很好的将它们聚合到一起。这也是我现在写博文的一种思维模式，同时推荐给你们。 万事开头难，感谢自己开了个好头，坚持写博客的日子很充实，希望自己能够继续坚持下来。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"用机器学习玩转FlappyBird","text":"&emsp;&emsp;两年前刚毕业的时候由于兴趣爱好就接触到了一些机器学习的内容，今天想到写这么一篇文章的主要原因是由于公司安排昨天去接送了一位做数据挖掘方向的教授，在接送途中跟她聊了一些有关数据挖掘与机器学习方面的内容并且从中受益，加上自己的部分兴趣于是就想产出一篇文章来说一下自己对于这块内容的理解，由于专业性的问题其中说法如果有误还请指出。 本篇博客相关代码托管于github游戏引擎与AI基于Vuejs+TypeScript+Tensorflow.js实现，点此在线预览如果这个项目激起了你的兴趣，欢迎分享与Star 概述本篇文章我将从三个方面去阐述我个人的机器学习经历及理解，也算是我这部分知识的一个成长经历。 初探机器学习：这里主要是描述一下我毕业不久后接触的一个Github仓库FlappyLearning，这个仓库用了一个很形象的例子来描述机器学习的作用，这个例子解决了我的一个疑惑，机器如何针对一个问题做出决策？ 反向传播与遗传算法：这两个算法很具有代表性，机器决策的核心是一个函数模型，问题的决策和模型的出参与阈值有关，所以机器学习的目的就是构造一个适用于问题的函数以及合适的分类阈值，而构造的过程可以用这两个算法来实现 基于Tensorflow玩转FlappyBird：Tensorflow是谷歌的一个机器学习开源库，能够很方便的构造一个神经网络，现在在js中也有实现版本，学习的途径也很多，这次我将基于Tensorflow来改造FlappyLearning这个仓库，顺便让自己学习Tensorflow的途中不那么枯燥 初探机器学习对于机器学习的概念解释我本人不是解释的很清楚，但是我可以从应用场景方面来分析一下机器学习在什么场景下会适用，机器学习现有的应用场景主要包括各种识别、推荐、广告、客服，这些场景我认为有以下几个共性 不容易用统一的逻辑归纳：比如人脸的特征值比对，我们很难编写统一的逻辑代码来确定怎样的两组特征值才算是比对成功 根据历史数据给出预测：比如网易云音乐的每日推荐，当你用得越久收藏/喜欢点击的越多，它推荐给和你口味歌曲的占比就越大，但是没有历史数据就会不准确。 都属于分类或聚类问题：在这里解释一下什么是分类与聚类，并给出相应的例子 分类：通过学习得到一个目标函数f，把每个属性集x映射到一个预先定义的类标号y中，比如根据人脸特征值来判断此次比对是属于比对成功/失败的哪种类别。 聚类：事先并不知道任何样本的类别标号，希望通过某种算法来把一组未知类别的样本划分成若干类别，比如广告投放业务中将用户群体分类然后分别投放不同的广告。 接下来我们利用FlappyLearning来了解一下机器是怎么通过自我学习做出决策的，首先我们来介绍一下这个游戏 Score：当前游戏得分 Max Score：代表游戏最高得分 Generation：代表鸟的代数，当50只鸟死完了就会通过遗传算法的优胜劣汰原则经过遗传变异生成新的五十只鸟参加游戏 Alive：代表当前游戏下鸟的存活量以及总数量 x1/x2…按钮：代表游戏运行速率，可以调快一点大概经过10-20代机器便能学会此游戏 机器如何通过自我学习来通关游戏的，我将从以下两个方面分析一下： 机器是如何来决策游戏走向的？ 如何获得一个合适的决策函数？ 机器是如何来决策游戏走向的我们上面讲到机器学习大部分可以分为分类与聚类两类问题，我们先来了解一下FlappyBird这个游戏的玩法，玩家需要根据小鸟所处的当前位置来控制小鸟的飞行（跳跃），从而使得小鸟不会撞到障碍物。 现在我们来换个更接机器地气的说法，假设每个小鸟都有一个飞行判断函数y=f(x1,x2…)，其中x1,x2…都是函数的输入参数，y是函数的输出参数，我们要根据结果y来决策当前环境是否需要跳跃，如果f(x1,x2…)这个函数适合于这个问题，那么小鸟就能根据这个函数完美的通关游戏。 如果按照上述方式去理解的话，机器学习的目的是什么就显而易见了，就是为了寻找一个适合于特定场景的决策函数，起到高准确率的预测效果，拿FlappyBird这个游戏举例，这个游戏的输入可以是以下很多种并且不限于此 一帧图片 小鸟距离的障碍物的垂直距离 小鸟距离障碍物的水平距离 为什么要专门拿输入这个概念来说？我们来模拟人类玩这个游戏，人类通过眼睛来获取小鸟的位置信息（其实在关注小鸟和障碍物的相对距离），来决策小鸟是否需要跳跃，我们把这个过程抽象成一个函数，那么你眼睛获取的位置信息就是输入，你的决策即是输出，而我要在这里说的是你获取的这个位置信息并不是最好的输入，设想一下，如果屏幕上打印了你现在距离障碍物的水平和垂直距离并且告诉了你每次跳跃将会相对移动多少距离，你是不是能更加容易的掌握这个游戏。 同理，一个更好更合理更有关联性的输入对于机器来说也能降低它的学习成本，假如你只给机器一个小鸟无关与障碍物的垂直距离作为输入参数，那么无论你用什么算法，他都永远无法学会玩这个游戏。在FlappyLearning这个仓库中，作者给予机器的输入信息为小鸟距离的障碍物的垂直距离与小鸟距离障碍物的水平距离。 讲到这里其实已经能够解答第一个问题了，机器其实是通过一个决策函数来代入一组输入然后根据输出结果关联到游戏的具体操作。如果你已经看到了这里你可以发现我的文章中将部分机器行为类比了人类行为，同样在后文中我也会使用类比这个思想去更通俗易懂的讲述其他问题。 如何获得一个合适的决策函数在FlappyLearning这个仓库中作者是使用了遗传算法去解决决策函数的构造问题，那么我们就要思考作者为什么选择遗传算法？遗传算法适用的场景有什么？如何在程序中使用遗传算法？在这部分我将围绕着这三个问题来解释。 为什么选择遗传算法 遗传算法属于一种随机搜索算法\b\b\b，这种算法很多时候不会给出一个“最优解”，而是给出一些较为接近的次优解，从中矮子里面拔将军。Flappy这个游戏从刚开始的一无所有到后面的随便通关依赖的就是随机搜索，先随机参数得到一个函数模型再不断的迭代得到一个次优解参与游戏。 其实在计算机世界中的很多理论都是根据现实生活中的理论映射来的，我们都知道达尔文进化论有一个核心思想叫做物竞天择适者生存，生物在不断进化的路途中总是会淘汰掉不适合的基因，所以最终留下的都是能够在这个世界正常生存下去的基因，如果我们将FlappyBird这个游戏当作一个世界，那么里面的小鸟不断的更新换代进化，保留下优质基因（游戏得分高的），最后总会有一批基因能够适应这个世界（通关这个游戏）。 遗传算法适用的场景 调度类问题，车间工程流程、飞机航线等等。工程、航行中所需要的资源消耗、时间等等权值看做“染色体”，几种染色体排列组合，最终选择其中的较优方案 辅助神经网络调节参数，FlappyLearning其实就是在做自动参数调节 游戏场景，比如我玩的游戏Dota2这种推塔生存类游戏，每局游戏后AI都可以总结自己不足的地方进行自我进化从而不断增强 遗传算法的运行流程 在知道了遗传算法的概念之后，它的运作流程概括来说应该是这样的： 生成一批随机的基因并加入游戏 保留游戏得分高的优质基因，淘汰游戏得分低的劣质基因，通关杂交变异生成部分新的基因，重复此流程 经过不断的迭代进化的基因能够基本适应游戏，达到通关（不死）的效果 反向传播算法简介反向传播要求有对每个输入值期望得到的已知输出，来计算损失函数的梯度，通常被认为是一种监督式学习方法，主要用于以下几个方面 函数逼近：用输入向量和相应的输出向量训练一个网络逼近一个函数 模式识别：用一个待定的输出向量将它与输入向量联系起来 分类：把输入向量所定义的合适方式进行分类 如何运用于FlappyBirdAI反向传播算法有一大特性就是需要有预期的输入输出集合，那我们就要思考如何给FlappyBirdAI提供一个训练数据集合，最简单的方式就是让玩家玩游戏从而生产训练数据，大体思路如下 这里有一个需要注意的问题，数据数据即函数模型的输入及预测项定义成什么？ 模型输入项首先我们要明白输入项需要有什么样的特性？ 前面我们讲到，与决策结果关联性越强的输入训练效果越好，还类比了人去玩游戏会注意哪些数据，所以在这里我们就采用人类玩游戏所观测的数据作为AI的训练数据，这里我设计了以下几个输入 小鸟当前的高度值 下一个障碍物的高度值 小鸟距离下一个障碍物的水平距离 模型预测项模型的预测输出项将作为小鸟的决策依据，我们需要设计一个可以较好判断决策的输出，举个两种输出设计作为例子 方案1：使用单项数字作为输出，并定义1代表跳跃，0代表保持不变（即下降） 方案2：使用数组作为输出，数组第一项代表跳跃概率，第二项代表保持不变概率 我们来分析以下这两项输出的优劣，首先我们知道训练出来的函数模型只能给出一个估计值（即不会绝对是0/1） 假设我们使用方案1作为输出结构，那根据这个结果我们怎么判断现在小鸟是否需要跳跃呢？&lt; 0.5？那么0.5这个数字又是怎么来的，没有任何依据 假设我们使用方案2作为输出结构，那么小鸟如何判断是否需要跳跃呢？result[0] &gt; result[1]即可，因此在这里我使用方案2作为输出结构 基于反向传播算法设计FlappyBirdAI流程设计 玩家通过玩游戏生成游戏数据，这里将采集游戏在每个时间点的小鸟高度、障碍物高度、小鸟距下一个障碍物的水平距离作为输入，以这个时间点玩家的操作作为输出 将游戏数据统一存储到浏览器的LocalStorage统一管理 AI利用玩家产生的游戏数据基于反向传播算法建立决策模型 AI进行游戏测试 界面设计界面左右分成两块内容，左侧为游戏界面，右侧为控制台界面，训练模型列表右侧有一个❓图标，点击可打开教学提示，下面描述一下如何训练一个FlappyBirdAI参与游戏 点击创建一个新的模型完成必要信息填写，这里主要是关联神经网络以及训练迭代次数的一些配置 在新的模型行中点击教学（或按空格）开始游戏，此时左侧游戏开始，玩家按J跳跃，游戏进行过程中左侧模型训练框中的数据量会不断增加，这些数据将持久化在LocalStorage中并作为AI的训练数据 当玩家认为数据量达到预期时（建议大于3000）可终止游戏，点击训练按钮开始训练决策函数模型，此时右侧会弹出训练进度图表 训练完成后游戏将由AI接手自动开始，右侧行会记录AI的最高得分 模型训练完成，玩家可以点击数据预测使用玩家生成的游戏数据样本交与AI进行预测分析，预测完成后将给出AI预测结果与玩家输入预期不符的数据列表 模型训练效果展示这里我人工玩了3万左右的数据量，相当于过了2500个障碍物，小鸟的最高得分是2400，具体运行效果如下 开发计划 参照FlappyLearning完成游戏引擎开发 完成用户游戏数据采集器与其持久化模块 引入Tensorflow.js基于游戏数据训练决策模型并使用其参与游戏 完成数据预测模块，便于对模型预测结果进行分析 分析AI参与游戏的能力，优化AI使其能够更好的适应游戏 机器训练过程中遇到的问题可能采集到错误数据游戏中机器训练的数据由玩家不断产生，也就是由玩家重复一局又一局的游戏来产生，那么玩家在游戏终止（小鸟死亡）前的一部分数据其实是属于错误操作数据，这类数据不应该交与机器去学习 解决方案 丢弃游戏结束前的部分数据在这里我维护了一个指定了大小的队列，\b负责缓存游戏最新的部分数据，脱离缓存的数据直接进入持久化模块，当游戏结束时还在缓存队列中的数据将被丢弃 数据样本分布不均匀在上述设计中游戏数据会基于运行的每一个时刻点来采集，这将导致数据集中操纵跳跃的数据会远小于无操作的数据，实际运行中也证明了这一点，跳跃操作数据大概占总数据集的3%，如此不均匀的数据集加入训练将使得决策模型出现一边倒的情况，即小鸟一直不跳跃，处理样本不平衡问题，主要有3种策略：从数据角度、从算法层面和模型评价层面，\b这边给出以下几种处理方案 方案一 扩大数据集当遇到类别不均衡问题时，首先应该想到，是否可能再增加数据，使得样本平衡，显然在我们这个场景中是不可能扩大了 方案二 重采样 上采样 通过增加稀有类训练样本数的方法，降低不平衡程度，一般用于数据集比较少的情况，重复的扩增样本中比例较小的那类数据达到样本平衡，此方法容易造成过拟合，而且会导致样本增大需要更多的计算资源 下采样 通过舍弃部分大类样本的方法，降低不平衡程度，一般用于数据集比较多的情况，随机的丢弃样本中比例较大的那类数据达到样本平衡，此方法会不可避免地丢弃大部分多数类样本造成信息损失 方案三 使用Focal loss损失器焦点损失函数Focal Loss被提出用于密集物体检测任务。它可以训练高精度的密集物体探测器，哪怕前景和背景之间比例为1:1000，在我们这个游戏中样本类别的数量比例大概是3:97，此损失函数是适用的但是现有的资料中Focal Loss损失函数基于Python的实现代码较多，而基于JS的几乎没有（也许是我没找到），经过一段努力的理解后，我放弃了此方案 最终我采用了上采样的方案，因为下采样方案丢弃掉大部分样本后会导致小鸟训练结果非常不理想，于是我选择牺牲计算资源的方式来保证小鸟的训练智能性，当然如果能写出Focal loss损失器的js版本也许会是个更好的解决方案 参考资料 FlappyLearning Github TypeScript 支持 — Vue.js Tensorflow.js 官方文档 开始 | TensorFlow.js 反向传播算法 | 机器之心 谁说遗传算法只能用来凑论文？它还有好多有趣的玩法 机器学习中解决数据不平衡问题 数据不平衡分类问题 | beatrice’s blogs","link":"/2019-09-06-machine-learning/"},{"title":"使用 Vuepress 编写组件示例文档的最佳实践","text":"&emsp;&emsp;这篇文章面向使用 Vuepress 来开发 Vue 组件文档库的用户服务，去年差不多这个时候我为公司开发了一个基于 AntDesignVue 封装的高阶组件库，经过一年的版本迭代与文档更新，收获了很多坑点，其中有一个就是关于组件示例维护相关的，今年有意重构组件库的文档与代码结构，后面会陆陆续续将踩到的坑点与相应的解决方案一一描述，好的进入今天的主题：文档示例编写的最佳实践方案。 关于最佳实践方案我提供了一个插件 vuepress-plugin-demo-container 来统一解决，插件的具体介绍、示例与使用文档 点此访问。 前言什么是组件示例文档？当你使用 Vue、React 或者其他语言编写了一个组件库，如 Element UI、Ant Design Vue 或是像我一样基于它们开发的业务封装库，都需要使用文档来支撑，而使用文档必然会包含代码与示例，这部分就是组件示例文档。 举个例子，Element UI 的 Color Picker 组件文档，其中就包含了多份示例代码，假设我们现在完成了组件开发，需要使用 Vuepress 写一份和它一样的使用文档，该怎么做呢？ 使用-Vuepress-构建组件示例文档方案一熟悉 Vuepress 的同学应该不难想到解决方案，由于 Vuepress 支持在 Markdown 中编写符合 Vue 语法的代码，所以我们可以这么写： ## 示例展示 &lt;template&gt; &lt;color-picker size=&quot;mini&quot;&gt;&lt;/color-picker&gt; &lt;/template&gt; ## 示例代码如下 ```html &lt;template&gt; &lt;color-picker size=&quot;mini&quot;&gt;&lt;/color-picker&gt; &lt;/template&gt; `` ` &lt;= 删除左侧空格 方案二如果示例中还包含 export default {} 代码块，我们可以借助 Vuepress 会自动注册 components 目录下组件的特性，或者通过 enhanceApp.js 钩子自己注册示例代码文件，然后使用 &lt;&lt;&lt; @/filepath 语法将示例代码文件引入，这部分操作的具体文档可以 点此查看，这么操作下来写法变成了这样： ## 示例展示 &lt;color-picker-basic-demo&gt;&lt;/color-picker-basic-demo&gt; ## 示例代码如下 ```html &lt;&lt;&lt; @/docs/.vuepress/components/color-picker-basic-demo.vue `` ` &lt;= 删除左侧空格 方案三当然这么做还不太行，我们还想要和 Element UI 或者 Ant Design Vue 一样漂亮的示例代码块，示例部分有框框包起来，代码部分可以省略/展开并提供复制功能、在线编辑功能。这倒也不难，我们可以自己开发一个 DemoBlock 组件来包裹组件示例，结构和样式都可以开发成你自己喜欢的样子，这部分做完后写法变成了这样： &lt;demo-block source=&quot;&lt;color-picker size=\\&quot;mini\\&quot;&gt;&lt;/color-picker&gt;&quot;&gt; &lt;template slot=&quot;demo&quot;&gt; &lt;color-picker size=&quot;mini&quot;&gt;&lt;/color-picker&gt; &lt;/template&gt; &lt;/demo-block&gt; 方案四你会发现 &lt;&lt;&lt; @/filepath 语法在组件内就不好使了，示例和代码得写两遍才行，而且代码还得作为一个 String 传递进去，那有没有办法在上述的实现基础上不写两边示例代码呢？ 办法当然是有的，程序员的智慧是无穷的，vuepress-plugin-extract-code 这个插件给了解决方案，它手动解析了组件内的 &lt;&lt;&lt; @/filepath 语法并将其转换成了代码文本，使用这个插件后写法变成了这样： &lt;reco-demo&gt; &lt;color-picker-basic-demo slot=&quot;demo&quot;&gt;&lt;/color-picker-basic-demo&gt; &lt;template slot=&quot;code-vue&quot;&gt; &lt;&lt;&lt; @/docs/.vuepress/components/color-picker-basic-demo.vue &lt;/template&gt; &lt;/reco-demo&gt; 方案-Element-UI到这里我们已经演变了四个版本，暂停一下我们去看看 Element UI 的组件文档是怎么编写的，点此查看 Color Picker 的文档，不想点的直接看下方示例： ::: demo 使用 v-model 与 Vue 实例中的一个变量进行双向绑定，绑定的变量需要是字符串类型。 ``` html &lt;template&gt; &lt;color-picker size=&quot;mini&quot; v-model=&quot;color&quot;&gt;&lt;/color-picker&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { color: '#409EFF' } } }; &lt;/script&gt; `` ` &lt;= 删除左侧空格 ::: 上述示例的渲染结果 点此查看，就这个示例来看，他至少有两点好处： 示例与代码不用写两遍 不复杂的示例可以直接写在 Markdown 中编写，不需要每个示例都建一个文件 而对比方案四的好处就在于第2点，相比之下后者有更高的灵活度，而方案四需要每个示例都建一个 Vue 文件并且被 Vuepress 全局引入。 如何实现？vuepress-plugin-demo-container 已经实现了上述最佳方案，在 Vuepress 中引入该插件即可获得想要的效果，关于该插件的介绍可以 点此查看，文档提供了它的工作原理、渲染效果、与插件比较及使用方式等描述，在这里我就不再赘述了，如果有建议或疑问可以通过或者评论或者 Issus 提供给我，我将尽力解答。 关于公众号","link":"/2020-05-31-vuepress-plugin-demo-container/"},{"title":"多数据源下SpringTransaction的探究","text":"&emsp;&emsp;最近的项目开发中有部分同事反馈到现开发系统中存在一些声明式（注解）事务不生效的问题，经过一个多小时的排查最终定位了问题所在，在此记录一下。 前言技术背景现开发的系统使用SpringBoot+JPA+Hibernate作为基础框架进行开发，当然整体上还包括一些权限方面Security等和本次问题排查无关的信息不再详谈，以下是核心库的版本信息。 SpringBoot：2.1.5.RELEASE Hibernate：5.3.10.Final 与常规系统不一样的地方在于，本系统由于业务的特殊性采用了双数据源的方案，既然是双数据源那么事务管理器方面也会对应配置两个。 双数据源实现方案基于JPA实现双数据源并不麻烦，只需要建立两个配置类分别定义DataSource、SessionFactory、PlatformTransactionManager对象，其中SessionFactory配置好Dao层的扫描路径区分开即可，以下是配置的示例代码： @Configuration public class SystemDSConfiguration { @Resource private Environment environment; /** * 系统数据源 */ @Primary @Bean public DataSource systemDataSource() { DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl(environment.getProperty(&quot;spring.datasource.system.jdbc-url&quot;)); druidDataSource.setUsername(environment.getProperty(&quot;spring.datasource.system.username&quot;)); druidDataSource.setPassword(environment.getProperty(&quot;spring.datasource.system.password&quot;)); druidDataSource.setDriverClassName(environment.getProperty(&quot;spring.datasource.system.driver-class-name&quot;)); return druidDataSource; } @Primary @Bean public SessionFactory systemSessionFactory(DataSource dataSource) { LocalSessionFactoryBuilder sessionFactoryBuilder = new LocalSessionFactoryBuilder(dataSource); sessionFactoryBuilder.scanPackages(&quot;com.zjcds.tj.server.system&quot;); sessionFactoryBuilder.setProperty(AvailableSettings.SHOW_SQL, &quot;true&quot;); return sessionFactoryBuilder.buildSessionFactory(); } /** * 配置hibernate事务管理器 * @return 返回事务管理器 */ @Primary @Bean public PlatformTransactionManager systemTransactionManager(DataSource dataSource) { return new JpaTransactionManager(systemSessionFactory(dataSource)); } } @Configuration public class BusinessDSConfiguration { @Resource private Environment environment; private DataSource businessDataSource() { // ... } @Bean public SessionFactory businessSessionFactory() { // ... } @Bean public PlatformTransactionManager businessTransactionManager() { // ... } } 声明式事务的使用熟悉SpringBoot的同学应该都知道，声明式使用事务只需要在服务的实现类或者函数上写上@Transactional注解即可，所以本系统对于事务的使用也很简单，示例代码如下： package com.zjcds.tj.server.business.service.impl; @Slf4j @Service @Transactional @RequiredArgsConstructor public class BusinessService implements IBusinessService { private final BusinessDTO.DTOConverter businessDTOConverter = new BusinessDTO.DTOConverter(); private final IBussinessDao businessDao; public BusinessVO saveBusiness(BusinessDTO dto) { log.debug(&quot;Save business {}&quot;, dto); BussinessEntity entity = businessDTOConverter.doForward(dto); bussinessDao.save(entity); throw new Exception(&quot;DB rollback test.&quot;); } // more code ... } 这个服务按照预期的运行结果BussinessEntity业务实体不应该被持久化到数据库中，但这篇文章的出现代表代码的执行结果正好与预期相反，所以接下来就要排查一下为什么事务没有生效呢？ 分析分析问题的产生原因之前我们先要搞懂@Transactional是怎么起作用的，我尝试把@Transactional 工作原理作为关键字在google中搜索，看了一部分文章后总结了有以下几类 讲@Transactional用法一类（如何使用、声明式、命令式） 讲事务概念性一类（事务的属性和行为等等） 讲Spring实现事务的原理与核心一类 结合搜索到的内容我准备按照自己的思路进源码看一看，毕竟源码面前无秘密。接下来我将叙述一下我如何从源码中找到我想要的东西。 整合搜索结果刚才我说到结合搜索到的内容，但没说是什么内容，这里我给一下搜索内容中我认为比较重要的一些知识点： SpringBoot有两种方式开启事务 自动装载依赖于TransactionAutoConfiguration 手动启用依赖于@EnableTransactionManagemen Spring事务是基于AOP运作的，TransactionInterceptor是其切面的实现类 @Transactional中提供了一些配置如transactionManager、rollbackFor等等，AnnotationTransactionAttributeSource负责读取这些配置 PlatformTransactionManager作为Spring中事务管理器的定义，包括getTransaction、commit、rollback三个方法 现在你也有这些知识点了，马上我们将进入Transactional的源码解析部分。要看源码首先我们要找到入口，我们先看第一个知识点，由于我的项目中没有使用@EnableTransactionManagemen注解，所以事务是通过TransactionAutoConfiguration自动完成装载配置。 SpringBoot自动装配有两种实现方式 第一种是类SPI机制，通过扫描META-INF/spring.factories文件中的定义的类进行装配 第二种是@Import机制，通过扫描@Import注解中定义的类进行装配 TransactionAutoConfiguration的探究TransactionAutoConfiguration的代码如下，代码量并不多并且我大部分都给出了注释，接下来我们该如何去看这个代码呢？ 结合第二个知识点，Spring事务是基于AOP运作的，既然是基于AOP那就一定会有切面的定义。 SpringAOP的实现方式有两种 第一种是JDK代理 第二种是Cglib代理 @Configuration // 代表某个类型的Bean存在时此配置才加载 @ConditionalOnClass(PlatformTransactionManager.class) // 代表当前类加载完成后将加载配置中的类 @AutoConfigureAfter({JtaAutoConfiguration.class, HibernateJpaAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class, Neo4jDataAutoConfiguration.class}) // 使@ConfigurationProperties注解生效 @EnableConfigurationProperties(TransactionProperties.class) public class TransactionAutoConfiguration { // 定义一个Bean托管于Spring容器 函数返回值代表BeanType 函数名称代表BeanName @Bean // 代表Spring容器中没有与之匹配的Bean时 此配置加载 @ConditionalOnMissingBean public TransactionManagerCustomizers platformTransactionManagerCustomizers( ObjectProvider&lt;PlatformTransactionManagerCustomizer&lt;?&gt;&gt; customizers) { return new TransactionManagerCustomizers( customizers.orderedStream().collect(Collectors.toList())); } @Configuration // 指定Bean在容器中只有一个 如果有多个需要用@Primary标记主体 @ConditionalOnSingleCandidate(PlatformTransactionManager.class) public static class TransactionTemplateConfiguration { private final PlatformTransactionManager transactionManager; public TransactionTemplateConfiguration( PlatformTransactionManager transactionManager) { this.transactionManager = transactionManager; } @Bean @ConditionalOnMissingBean public TransactionTemplate transactionTemplate() { return new TransactionTemplate(this.transactionManager); } } @Configuration // 指定Bean存在时才加载此配置 @ConditionalOnBean(PlatformTransactionManager.class) @ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class) // 不难发现 这里有关于aop的定义 我们将先观察此配置文件 public static class EnableTransactionManagementConfiguration { @Configuration // 这里通过注解手动启用了事务模块 @EnableTransactionManagement(proxyTargetClass = false) // 配置文件中指定值匹配时生效 @ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;, matchIfMissing = false) public static class JdkDynamicAutoProxyConfiguration { } @Configuration @EnableTransactionManagement(proxyTargetClass = true) @ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = true) public static class CglibAutoProxyConfiguration { } } } 观察这个类你很快就能发现一个关键点，你要找到切面配置就在最下方EnableTransactionManagementConfiguration这个类中，而这个类又使用了@EnableTransactionManagement这个注解，而它也是我们前面提到手动开启事务的注解，所以无论如何我们都得关注一下它。 EnableTransactionManagement的探究首先我们看看@EnableTransactionManagement的代码 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(TransactionManagementConfigurationSelector.class) public @interface EnableTransactionManagement { // 是否要创建基于Cglib的代理，否则创建JDK的代码 boolean proxyTargetClass() default false; // 应该如何采用事务通知 Proxy 或者 Aspectj AdviceMode mode() default AdviceMode.PROXY; int order() default Ordered.LOWEST_PRECEDENCE; } 对我来说，该代码就一个有效信息，加载了TransactionManagementConfigurationSelector这个配置类，所以接下来看看它的代码 // AdviceModeImportSelector 提供根据AdviceMode的值进行配置切换的策略 public class TransactionManagementConfigurationSelector extends AdviceModeImportSelector&lt;EnableTransactionManagement&gt; { @Override protected String[] selectImports(AdviceMode adviceMode) { switch (adviceMode) { case PROXY: // 基于JDK代理实现切面配置 默认采用 return new String[]{AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()}; case ASPECTJ: // 基于ASPECTJ实现切面配置 return new String[]{determineTransactionAspectClass()}; default: return null; } } private String determineTransactionAspectClass() { return (ClassUtils.isPresent(&quot;javax.transaction.Transactional&quot;, getClass().getClassLoader()) ? TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME : TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME); } } 如果不特殊配置，这里会默认采用JDK动态代理的方案，所以AutoProxyRegistrar、ProxyTransactionManagementConfiguration这两个配置类会被加载 AutoProxyRegistrar @Override public void registerBeanDefinitions(..) { ... if (mode == AdviceMode.PROXY) { AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry); if ((Boolean) proxyTargetClass) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); return; } } ... } ProxyTransactionManagementConfiguration @Configuration public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration { @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME) // 用作Bean的分类 @Role(BeanDefinition.ROLE_INFRASTRUCTURE) // 事务增强器 public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() { BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor(); advisor.setTransactionAttributeSource(transactionAttributeSource()); advisor.setAdvice(transactionInterceptor()); if (this.enableTx != null) { advisor.setOrder(this.enableTx.&lt;Integer&gt;getNumber(&quot;order&quot;)); } return advisor; } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) // 事务注解信息读取 public TransactionAttributeSource transactionAttributeSource() { return new AnnotationTransactionAttributeSource(); } @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) // 方法拦截器 public TransactionInterceptor transactionInterceptor() { TransactionInterceptor interceptor = new TransactionInterceptor(); interceptor.setTransactionAttributeSource(transactionAttributeSource()); if (this.txManager != null) { interceptor.setTransactionManager(this.txManager); } return interceptor; } } 至此我们已经找到了事务方法拦截器TransactionInterceptor的定义之处，接下来就看看我们的方法被事务拦截后干了什么？ TransactionInterceptor探究阅读TransactionInterceptor这个类不难发现invoke即是事务拦截的主要实现，而它仅有两句代码而已，主要是调用了父类的invokeWithinTransaction方法。 // MethodInterceptor 方法拦截接口 invoke作为具体实现函数 public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable { public TransactionInterceptor() { } public TransactionInterceptor(PlatformTransactionManager ptm, Properties attributes) { setTransactionManager(ptm); setTransactionAttributes(attributes); } public TransactionInterceptor(PlatformTransactionManager ptm, TransactionAttributeSource tas) { setTransactionManager(ptm); setTransactionAttributeSource(tas); } @Override @Nullable // 事务方法拦截的具体实现 调用了父类的invokeWithinTransaction方法 public Object invoke(MethodInvocation invocation) throws Throwable { // 获取代理的目标类 Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed); } //--------------------------------------------------------------------- // Serialization support //--------------------------------------------------------------------- private void writeObject(ObjectOutputStream oos) throws IOException { // ... } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { // ... } } 紧接着我们查看父类的invokeWithinTransaction方法，代码量虽然比较多，但是结合项目的配置很快就会发现，由于我们使用的是JpaTransactionManager所以后面的条件是不会进去的，因此我们只需要看前面一小段的代码即可，这段代码中有一个获取事务管理器的函数叫做determineTransactionManager，双数据源下的事务失效很有可能是事务管理器获取错误导致的。 // BeanFactoryAware 为当前类提供了 BeanFactory 资源 // InitializingBean 当前类构造完成时将收到通知 public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean { @Nullable protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable { TransactionAttributeSource tas = getTransactionAttributeSource(); // 读取 @Transactional 中定义的属性 final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); // 根据定义的属性获取一个事务管理器 final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) { // 由于本项目配置的是JpaTransactionManager 将进入此代码块 // 必要时创建事务 TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal; try { // 执行被代理的函数并获取结果 retVal = invocation.proceedWithInvocation(); } catch (Throwable ex) { // 回滚事务并将异常原样抛出 completeTransactionAfterThrowing(txInfo, ex); throw ex; } finally { cleanupTransactionInfo(txInfo); } // 提交事务并返回结果 commitTransactionAfterReturning(txInfo); return retVal; } else { final ThrowableHolder throwableHolder = new ThrowableHolder(); // ... more code } } } 我们看到determineTransactionManager这个方法是根据@Transactional中的某些属性来获取事务管理器，接下来看看它具体是怎么实现的。 @Nullable protected PlatformTransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) { if (txAttr == null || this.beanFactory == null) { // 返回方法拦截器中预先定义的事务管理器 return getTransactionManager(); } String qualifier = txAttr.getQualifier(); if (StringUtils.hasText(qualifier)) { // 读取qualifier属性 如果其不为空则去Bean工厂中获取对应名称的事务管理器 return determineQualifiedTransactionManager(this.beanFactory, qualifier); } else if (StringUtils.hasText(this.transactionManagerBeanName)) { // 如果方法拦截器中定义了名字则采用容器中同名的事务管理器 return determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName); } else { PlatformTransactionManager defaultTransactionManager = getTransactionManager(); if (defaultTransactionManager == null) { defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY); if (defaultTransactionManager == null) { // 如果都不匹配就获取定义为主体的事务管理器 defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class); this.transactionManagerCache.putIfAbsent( DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager); } } return defaultTransactionManager; } } 问题浮出水面经过debug分析我找到了事务失效的原因，由于我的Bussiness模块获取了System模块的事务管理器导致其事务失效。 这里有人可能会感到疑惑，获取了错误的事务管理器不会报错么？ 这块我们可以这么分析，想想在mysql中我们是怎么开启事务的。 mysql&gt; begin; # 数据库A开启事务 Query OK, 0 rows affected (0.00 sec) mysql&gt; delete from sys_user where id = 1; # 数据库A执行删除脚本 Query OK, 1 row affected (0.01 sec) mysql&gt; rollback; # 数据库A回滚 Query OK, 0 rows affected (0.01 sec) mysql&gt; 同样Spring在使用事务时也是在远程执行脚本，只不过流程变成了下面这个样子，数据库A开启了事务我们却在数据库B执行脚本，理论上是不会报错的，但是数据库B的事务肯定不会生效。 mysql&gt; begin; # 数据库A开启事务 Query OK, 0 rows affected (0.00 sec) mysql&gt; delete from sys_user where id = 1; # 数据库B执行删除脚本 Query OK, 1 row affected (0.01 sec) mysql&gt; rollback; # 数据库A回滚 Query OK, 0 rows affected (0.01 sec) mysql&gt; 解决方案既然问题已经找到了接下来要考虑下如何解决，其实上文很早的时候就提到了@Transactional有一个配置叫做transactionManager，可以指定当前启用事务的方法用哪个事务管理器。 @Target({ElementType.METHOD, ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface Transactional { @AliasFor(&quot;transactionManager&quot;) String value() default &quot;&quot;; @AliasFor(&quot;value&quot;) String transactionManager() default &quot;&quot;; // ... } 所以最简单的一种方案就是给所有的Service实现类都加上指定事务管理器名称的@Transactional注解，但是我们的系统开发已经接近尾声，我不想一个一个去修改文件，有没有不修改原来的代码而采用新增代码的方式去解决呢？ 办法当然是有的，整理一下前面提到的获取事务管理器的流程，大概如下所示： TransactionAttributeSource组件负责解析@Transactional的配置得到TransactionAttribute 读取TransactionAttribute中的qualifier用于获取一个具名的事务管理器 如果我们能够替换一个TransactionAttributeSource的实现让其根据包名返回不同的事务管理器名称，即可完成上述需求。 要替换我们就得知道这玩意儿在哪儿定义的，其实阅读源码的过程中我们已经看到过了，ProxyTransactionManagementConfiguration这个类负责了定义工作，我们只需要重新定义一个ProxyTransactionManagementConfiguration即可完成替换了，因为TransactionAutoConfiguration中有@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)的限定，而AbstractTransactionManagementConfiguration即是我们需要自定义配置的父类，自定义后事务的自动化配置将不会加载EnableTransactionManagementConfiguration，所以不会出现Bean的定义冲突问题。 public class TransactionAutoConfiguration { @Configuration @ConditionalOnBean(PlatformTransactionManager.class) @ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class) public static class EnableTransactionManagementConfiguration { // more code... } // more code } 废话不多说直接给代码，此配置可通过包名前缀实现动态切换事务管理器，撒花完结。 @Configuration public class MyProxyTransactionManagementConfiguration extends ProxyTransactionManagementConfiguration { /** * 重写了事务注解属性解析器的内容 * 让其根据包名动态的获取事务管理器名称 * 以达到不修改Service代码的前提下保证多数据源下的事务能够正常运行 * * @return 事务注解属性解析器 */ @Bean @Role(BeanDefinition.ROLE_INFRASTRUCTURE) @Override public TransactionAttributeSource transactionAttributeSource() { return new AnnotationTransactionAttributeSource() { @Override public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) { DefaultTransactionAttribute attribute = (DefaultTransactionAttribute) super.getTransactionAttribute(method, targetClass); if (attribute != null &amp;&amp; attribute.getQualifier() == null) { // 获取方法归属类的全名 String name = method.getDeclaringClass().getName(); if (name.startsWith(&quot;com.zjcds.tj.server.system&quot;)) { attribute.setQualifier(&quot;systemTransactionManager&quot;); } else if (name.startsWith(&quot;com.zjcds.tj.server.business&quot;)) { attribute.setQualifier(&quot;businessTransactionManager&quot;); } } return attribute; } }; } } 关于公众号","link":"/2020-01-09-spring-transaction/"},{"title":"随笔——缓存系列开篇","text":"&emsp;&emsp;跨过了2019来到了2020年，新年新气象，准备写一些系列性质的文章，旨在更好的对知识归纳总结，更系统的理解一块知识面。好的废话不多说，2020年开篇的主题是缓存系列，是个程序员或多或少都跟缓存打过交道，作为一个Java程序员大部分时候还是在应用层使用缓存，接触的缓存框架和中间件会比较多，但是本系列并不想仅限于应用层讲述缓存，我将从底层到CPU、操作系统，中层到浏览器、CDN，上层应用程序来讲述缓存的应用，通过这个系列能学习到缓存的应用场景及时机。 前言新的一年我将稍微改变一下自己的文章排布，将复杂的问题作为一个系列分块讲述，提取模块的重点并减少单篇文章的篇幅，降低阅读时间。本篇文章作为缓存系列的开篇之作第一步自然是挖坑，本系列将从以下几个方面分多篇文章来讲述缓存。 缓存系列开篇——缓存定义、浏览器、CDN中的缓存 缓存系列二——操作系统、CPU中的缓存 缓存系列三——应用程序中的缓存 缓存系列四——常见的缓存中间件 缓存系列五——缓存常见问题与总结 什么是缓存关于定义你去搜索wiki、百度百科就会发现给出来的都是跟存储器相关的，这其实不是我想要的答案。 我认为的缓存是一个抽象的概念，它可以是一个存储器、一个应用程序或者一个服务器，但不管它是什么东西，它的行为永远都是保存一份原始资源的副本并提供一个高速的访问途径，而有这个行为的任意东西都可以称之为缓存。 知道缓存的定义后它的应用场景也就很清楚了，当你有频繁读取的需求，且源数据访问速度远低于本地访问时，可采用缓存的解决方案。 浏览器中的缓存为何使用缓存要知道浏览器为何使用缓存我们就得知道我们使用浏览器打开一个网页时，浏览器做了什么？ 一个网页是由HTML+JS+CSS+静态文件组成的，当我们使用浏览器打开一个网页时，浏览器其实是在访问Web服务器的HTML、JS、CSS、静态文件（如图片、gif）等资源，做过Web开发的都知道JS与CSS以及静态文件在网站上线后基本不会改变，HTML作为网页结构如果是服务端渲染那么它是可变的。 结合这些知道再看看我们上面提到的缓存应用场景 浏览器作为一个网页客户端，自然会有频繁请求网页的需求，即频繁读取Web服务器的资源 浏览器访问Web服务器的速度肯定比访问本地的速度慢一个量级 于是浏览器就采用了本地缓存服务器资源的方式来减少发往服务器的请求，也提高了页面加载的效率，在用户使用时也会感受到第一次打开页面的时候有点慢，后面就快了很多。 这里会有一个问题，浏览器不能缓存所有数据，这样会导致你网页重新发布了但是客户浏览器的网页确一直不更新，\b所以浏览器需要根据服务器的安排来缓存数据。 如何使用浏览器缓存服务器如何控制浏览器的缓存呢？这就得讲讲HTTP协议了，因为浏览器获取服务器资源都是通过此协议进行交互访问。为了更好的讲述浏览器缓存流程我截取了本人博客网站的一个CSS资源的响应体如下 Request URL: https://chenjianhui.site/css/back-to-top.css Request Method: GET Status Code: 200 OK (from disk cache) Remote Address: 120.79.79.226:443 Referrer Policy: no-referrer-when-downgrade Accept-Ranges: bytes Content-Length: 343 Content-Type: text/css Date: Tue, 07 Jan 2020 02:19:37 GMT ETag: &quot;5e0aac7c-157&quot; Last-Modified: Tue, 31 Dec 2019 02:03:40 GMT Server: nginx/1.15.12 Referer: https://chenjianhui.site/ User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36 CSS Content ... 重点关注以下几个响应头部信息，这部分头部实现了协商缓存。 Status Code：请求响应码，这里200代表成功，后面还有一个括号from disk cache描述了这个资源来自于本地磁盘的缓存。 ETag：资源的特定版本的标识符，类似于资源的指纹（Hash值），用于提供给浏览器快速确定资源是否变化。 Last-Modified：资源做出修改的日期及时间，通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致，由于精确度比ETag要低，所以这是一个备用机制。包含有If-Modified-Since或If-Unmodified-Since首部的条件请求会使用这个字段。 那么整个网络请求的流程是怎样的呢？ 客户端get请求资源，服务器返回资源，并在响应头中带上了ETag与Last-Modified的值，此时客户端将资源缓存在本地。 客户端再次请求这个资源，在启用缓存的情况下，将上次请求的ETag属性值作为If-None-Match的值，Last-Modified的值作为If-Modified-Since随请求头发给服务器。 服务器判断资源现有的ETag与If-None-Match的值是否相等，如果相等，会返回304和空的响应体。浏览器根据304取本地缓存。 这就是浏览器缓存的全部了吗？ 当然不是，还有两个响应头部是用于浏览器缓存的，它们称之为强制缓存，分别是 Expires： 响应头包含日期/时间，即在此时候之后，响应过期。如果是无效的日期代表资源已经过期。 Cache-Control：通过指定指令来实现缓存机制，缓存指令是单向的。比如Cache-Control: max-age=30代表该资源可以缓存的30秒，max-age的优先级将高于Expires。 实践浏览器缓存在知道了缓存头部的作用后，我们可以写一些代码来实践一下让浏览器缓存我们的数据。 由于使用Java代码启动一个HTTP服务器还需要经过编译过程太过麻烦，因此这里采用Nodejs来实现缓存示例 const PORT = 3030; const CACHE_SECONDS = 10; // 加载http模块 var http = require('http'); // 创建http服务器 var server = http.createServer(function (req, res) { if (req.url === '/test.js') { // 设置缓存响应头部 res.setHeader('Cache-Control', `max-age=${CACHE_SECONDS}, public`); res.end(`document.body.append('Load script test.js on ${new Date()}')`) } else { // 首页加载 test.js 脚本 res.end(`&lt;html&gt;&lt;body&gt;&lt;h1&gt;Script will cache ${CACHE_SECONDS} seconds&lt;/h1&gt;&lt;/body&gt;&lt;script src=&quot;http://localhost:${PORT}/test.js&quot;&gt;&lt;/script&gt;&lt;/html&gt;`); } }) server.listen(PORT) console.log(`Listening in http://localhost:${PORT}`) 这段代码可以拷贝到有Nodejs环境的机器中使用node xxx.js直接运行，它主要做了以下几件事情: 监听3030端口启动了一个HTTP服务器，默认提供了一个HTML页面，该页面通过script标签加载了test.js脚本。 当访问test.js脚本时设置了Cache-Control: max-age=10, public响应头部，即允许浏览器缓存该资源10秒。 test.js脚本向页面写入了一行字符串，该字符串包含了服务器响应脚本的时间new Date()。 现在我们通过浏览器测试一下缓存头部是否生效，运行脚本文件后在浏览器打开http://localhost:3030如下图所示。 可以看到这里显示加载脚本的时间是14:12:13，现在我们十秒内刷新一下页面，运行效果如下图。 这里可以看到显示效果上没有改变，但是网络监控方面显示脚本是从缓存中获取(from memory cache)，现在我们静候一段时间再点击刷新，脚本缓存失效重新从服务器上获取了最新资源，时间变成了14:12:45，运行效果如下图。 有关其他的缓存头部可以根据相同的方式进行测试，多动手对自己理解这些HTTP响应头部以及协议会有很大的帮助。 CDN中的缓存为什么CDN缓存要和浏览器缓存放一起说呢？因为它们都是为了提高网页访问速度而设计的。浏览器缓存是提高了频繁请求资源的速度，CDN缓存提高了单次请求资源的速度。 CDN是什么CDN是Content Delivery Network的简称，即“内容分发网络”的意思。一般我们所说的CDN加速，一般是指网站加速或者用户下载资源加速。 那么它如何做到加速效果呢？ 就近访问原则，就如同你找水电燃气的缴费点，由于各个缴费点提供的服务是一样的，你肯定会选择离你最近的服务点进行缴费。同理在访问网页时我们也可以根据客户机的位置，为它选择一个最近的服务节点提供资源服务，寻找最近服务节点的这个过程就叫做CDN加速。 CDN工作原理了解CDN的工作原理之前我们先来看看传统网站的访问过程 浏览器输入chenjianhui.site 浏览器请求DNS服务器，查询到chenjianhui.site对应服务器的IP 向该服务器发起HTTP请求得到网页、加载其他内容、渲染页面等等（这里简略了一些东西、比如我们上面聊到的浏览器缓存） 这里需要重点讲一下第2步，因为CND就是在这一步做了文章，其具体过程如下所示： chenjianhui.site解析成IP的具体过程 操作系统查询本地缓存（host文件或者是浏览器的缓存）是否有解析记录，有则直接使用，没有则进入第2步 操作系统向LocalDNS查询域名的IP地址，一般称运营商的DNS服务器为LocalDNS，这里LocalDNS会先查询本地缓存，没有则进入第3步 LocalDNS向RootDNS查询得到权威服务器，传说中全球只有几台的那些服务器称之为RootDNS LocalDNS向权威服务器查询IP地址，缓存这个地址并将结果返回给客户端 CDN其实就是作用于域名解析的第4步，传统的网站第4步是返回一个IP地址，而加入CDN后这里一般返回一个CNAME记录 这里要补充一个知识点，常见的DNS解析记录有A，AAAA，CNAME等等，其中 A记录是域名到IPV4地址的 AAAA记录是域名到IPV6地址的 CNAME记录是域名到域名的，即你去问问这个域名，他知道该解析成什么 LocalDns得到一个CNAME记录，向智能调度DNS查询域名的ip地址 智能调度DNS 根据一定的算法和策略(比如静态拓扑，容量等)，将最适合的CDN节点IP地址回应给LocalDns 参考资料 MDN ETag MDN Last-Modified MDN Cache-Control CDN的原理以及其中的一些技术 关于公众号","link":"/2020-01-07-cache-opening/"},{"title":"随笔——如何打造一个安全的系统","text":"&emsp;&emsp;作为一个在主打网络安全系公司实习过的人，不得不了解下系统安全设计相关的知识，本篇博客将以一个虚拟的需求开始，尝试以讲系统设计者阿辉与黑客小刘互相博弈的故事，这样的方式去让大家学习到我了解到的网络安全。 虚拟的需求\b\b2018年3月某日位于G城的一个下午，公司领导拍脑袋想出了一个需求，经过了三个小时的开会讨论，系统的功能模块确定了，名字就叫弱鸡掌上生活APP，下面是它的功能模块图 需求总结来说很简单 平台客户使用此平台进行生活缴费 平台服务人员受理客户的服务，并在每个月底进行对账\b\b 那既然是有管理平台的系统肯定少不了权限，作为一个客户服务人员肯定不能参与对账吧，所以阿辉先开始了权限相关的设计，业务方面委派给了大超。 系统权限设计开始权限设计之前阿辉先了解了一下权限设计的相关知识，说到权限就离不开权限设计的原则以及RBAC的设计方式。 权限设计的原则 最小特权原则：用户在完成某个任务时，其得到的权限不应该大于完成该任务所需要的最小权限。 职责分离原则：权限分配时要考虑权限互斥的情况，如文章的创建与审核权限如果被一个用户同时拥有，那么将会出现自动审核的情况。 数据抽象原则：权限设计时不单纯的以对数据的增删改查操作来定义权限，需要结合业务场景来定义权限，如政府申报单审核的初审、复审、终审业务应该定义成三个权限，使其粒度更加合理。 什么是RBAC 在20世纪90年代期间，大量的专家学者和专门研究单位对RBAC的概念进行了深入研究，先后提出了许多类型的RBAC模型，其中以美国George Mason大学信息安全技术实验室（LIST）提出的RBAC96模型最具有系统性，得到普遍的公认 RBAC模型是web权限设计领域中一个成熟的理论方案，它全称为Role-Based Access Control即以角色为基础的访问控制，其设计的核心思想即将角色、用户、权限关联起来，系统可以根据不同的账号获得背后的角色，进而从角色中获取权限信息来判断是否有某些资源的访问权限。 那RBAC解决了什么问题呢？ 我们先来看看传统无角色概念的权限设计，用户被直接授予权限的缺点。 权限配置相当麻烦 无法快速为多个用户批量删除/编辑权限 用户多身份下权限配置维护麻烦 而RBAC不仅解决了传统权限设计的缺点，还支持了权限设计的三个原则 最小特权原则：RBAC模型可以通过授予角色权限的多少与大小来决定用户拥有的特权，用户得到的权限不应该大于完成某任务所需要的权限。 职责分离原则：RBAC模型可通过指派互斥的角色完成同一个任务。 数据抽象原则：RBAC模型的权限实体即可抽象成许可权，其支持的抽象程度与模型的实现细节有关。 什么是RBAC96模型RBAC96包括RBAC0~RBAC3四个概念性模型，在这里分别介绍一下 RBAC0符合RBAC概念系统的最低要求RBAC0指出了角色，用户，访问权限和会话的关系，用户至少包含一个角色，角色至少包含一个权限，一个用户可以激活多个角色，用户、角色、权限均是多对多的关系 RBAC1在RBAC0的基础上增加了角色继承的关系RBAC1定义了一个角色可以获得另一个角色的权限继承权，在有上下级的机构体系中此模型可适用 RBAC2在RBAC0的基础上引入了SSD和DSDRBAC2限制了权限授予操作的限制性，防止用户拥有概念上互斥的权限，如上文说到的文章创建与审核权限。 SSD(Static Separation of Duty)静态职责分离 互斥角色规则：同一个用户在两个互斥的角色中只能选择一个 基数规则：一个用户拥有的角色是有限的，一个角色拥有的权限也是有限的 先决规则：用户想获得高级的角色，首先必须拥有低级的角色 DSD(Dynamic…)动态职责分离 运行时互斥规则：一个用户可以拥有两个角色，但运行时只能激活一个角色 RBAC3是RBAC1和RBAC2的集合 支持RBAC的主流框架 Shiro Spring Security 在对比了两者的优缺点后，阿辉凭着对Spring的亲切感选择了Spring Security，根据官方的文档描述阿辉很快就完成了权限相关的设计，结合大超开发的话费充值功能弱鸡APP快速上线了。 系统安全防护黑客小刘在一个阳光明媚的下午，张三在某不知名奶茶店连着wifi悠闲的喝着奶茶，突然收到一条手机余额只剩3毛的欠费提醒，\b\b张三第一时间想到了弱鸡APP，熟练的打开它并完成了一笔话费充值，此时手机发出了一条HTTP请求如下 POST /service/call/charge HTTP/1.1 Host: app.ruoji.cn Content-Type: application/json Cache-Control: no-cache Access-Token: 56ad9e8e-e404-5f6a-a7d3-a3125583f2cc {&quot;mobile&quot;:&quot;13312123312&quot;,&quot;amount&quot;:50} 另一边黑客小刘已在此等候多时，他早已经控制了奶茶店的wifi，并不断的截获发往公网的请求内容，专业的小刘敏锐的捕捉到张三的这个请求不一般，他尝试着修改请求内容为 POST /service/call/charge HTTP/1.1 Host: app.ruoji.cn Content-Type: application/json Cache-Control: no-cache Access-Token: 56ad9e8e-e404-5f6a-a7d3-a3125583f2cc {&quot;mobile&quot;:&quot;17477212341&quot;,&quot;amount&quot;:300} 不多久，小刘朋友的手机显示话费到账300元，小刘心喜找到弱鸡APP的一个漏洞，可以利用此漏洞给别人充话费然后自己收取部分费用，由此迎娶白富美走上人生巅峰！ 三天后弱鸡APP收到越来越多的用户投诉，程序员大超检查日志发现了自己系统存在请求能被篡改的漏洞，这可不得了，大超立马去咨询老大阿辉该怎么解决？阿辉知晓后，安慰了大超没关系，问题发现得早，损失还不是很严重，然后开除了大超，开始了弱鸡APP的修复之路。 接口防篡改设计阿辉为了防止接口被篡改，引入了参数签名的概念 客户端与服务端约定了一个字符串ABBACC，参与签名算法 客户端发送网络请求之前使用MD5算法对参数体+ABBACC做一次哈希得到签名值signature，放到请求的query部分发往服务器 服务端接收到请求后同样使用MD5算法对参数体+ABBACC做一次哈希得到签名值，并核对query部分的签名值，匹配则代表请求未被篡改 于是话费充值接口的请求体变成了如下示例，只要约定字符串ABBACC不泄漏，理论上请求是不可篡改的 POST /service/call/charge?signature=BB9BBD082F5C05B5BBC8BF7F6A59FD72 HTTP/1.1 Host: app.ruoji.cn Content-Type: application/json Cache-Control: no-cache Access-Token: 572caf12-b62e-b3ce-c969-b36ebe165078 {&quot;mobile&quot;:&quot;13312123312&quot;,&quot;amount&quot;:50} 阿辉的思考🤔黑客小刘的事件发生后，阿辉意识到客户的网络大部分情况不能保证是在一个安全的环境运行，客户在弱鸡APP上的操作最终也只不过是转换成一堆报文在网络上传递，要获取这些报文简直轻而易举。想到这里阿辉开始把自己当成一个黑客，来寻找自己弱鸡APP的漏洞。 token盗用与重放攻击敏锐的阿辉没过多久就发现弱鸡APP还存在一些致命的漏洞，由于系统是针对APP提供服务，APP不像网页端有cookie-session机制可以直接使用，而是使用token来鉴别用户，且弱鸡APP为了提高用户体验将token的有效期设置的很长，防止用户经常需要登录，这就存在用户token的盗用问题。 黑客通过控制wifi抓取弱鸡APP的网络请求 分析请求内容很容易找到令牌位置 使用令牌伪装成用户干其他事情 与token盗用同时存在的还有重放攻击问题，黑客可以通过重新发送张三的话费充值请求，亲切的帮其多充几次话费 防止token盗用防止token盗用即让token的时效性降低，问题演变成如何即满足用户能够长期保持登录状态又能降低token的时效性？refresh_token出现了，从名字上很容易看出，它是为刷新token而存在的token，这么说其实有点绕，总结它与普通token的区别是 时效性比token长很多 用于token失效后的更新操作凭证 现在阿辉把token的时效性设置成了一小时，当token失效时就发送一个请求来换取新的token，refresh_token的时效性设置成一周，如果用户一周没有使用app则需要重新登录 POST /service/token/refresh?signature=CAB800F028D909F0E0B8B12D11A8FB08 HTTP/1.1 Host: app.ruoji.cn Content-Type: application/json Cache-Control: no-cache Access-Token: 572caf12-b62e-b3ce-c969-b36ebe165078 {&quot;refresh_token&quot;:&quot;572asc2-a19c-a2de-c719-b36fbe465078&quot;} 防止重放攻击简单来说防止重放攻击就是要让每一个网络请求体只能用一次，阿辉很快就想到一个方案 随机数方案 \b客户端发送请求时生成一串随机数放到请求体中 服务端维护一个随机数池，每个收到的随机数都放到池中，当请求体中的随机数与池中冲突时认为是重复请求不受理 此方案有一个很明显的缺陷，随机数池将被无限扩充，终有一日所有请求都将无法受理，阿辉思考片刻提出了第二个方案 随机数+时间戳方案 客户端发送请求时生成一串随机数与时间戳放到请求体中 服务端先校验时间戳，与服务器时间相差五分钟则拒绝处理 时间戳校验通过则将随机数放置随机数池中，并给此随机数设置一个五分钟的有效期 如果随机数与随机数池中冲突时认为是重复请求不受理 现在充值话费的请求变成了 POST /service/call/charge?signature=D4E8FEE98427C555135FEAAE258077DE HTTP/1.1 Host: app.ruoji.cn Content-Type: application/json Cache-Control: no-cache Access-Token: 572caf12-b62e-b3ce-c969-b36ebe165078 {&quot;mobile&quot;:&quot;13312123312&quot;,&quot;amount&quot;:50,&quot;r&quot;:182713,&quot;timestamp&quot;:1576576992917} 至此，黑客无法再篡改或者重复利用截获的网络报文了，但是好景不长，没过多久弱鸡APP的客服收到部分用户被盗号的投诉，阿辉不敢怠慢，很快就发现了问题所在 数据裸奔阿辉发现现在的请求确实篡改不了了，但是部分敏感的请求报文是在互联网上”裸奔“的，比如下面这个登录请求 POST /service/login?signature=B1D927521CA28E458C4192CF2090631D HTTP/1.1 Host: app.ruoji.cn Content-Type: application/json Cache-Control: no-cache {&quot;account&quot;:&quot;zhangsan&quot;,&quot;password&quot;:&quot;zhangsan123456&quot;,&quot;r&quot;:131763,&quot;timestamp&quot;:1576576992917} 黑客稍微分析一下就知道这是一个账号为zhangsan密码为zhangsan123456的登录操作，接下来黑客只需要打开弱鸡APP使用该账号密码进行登录并修改密码即可不费吹灰之力盗号，这种数据明文传输的行为即是数据裸奔 那么如何防止数据裸奔呢？ 传输加密阿辉第一时间想到的解决方案是客户端和服务器都约定好加密算法和密钥，HTTP的请求与响应报文都使用这套加密算法和密钥进行通信，常用的对称加密算法有DES、3DES、AES、RC5、RC6等，阿辉采用AES算法并与APP端约定好了密钥为ACMYTE，登录请求报文变成了如下示例 POST /service/login?signature=B1D927521CA28E458C4192CF2090631D HTTP/1.1 Host: app.ruoji.cn Content-Type: application/json Cache-Control: no-cache {&quot;secret&quot;:&quot;6780bfw0YjIh7UoByQEcP8qpBnJPj0lgphVBLEbBsU78D1QwBQ9JMggNaCMArXgH8NKG4x+le2zx+HtXnGKTeGvrrV32hGC5GJhSrxCkQDGJbokCKyzsHTlq+4DO3Bej&quot;} 这样黑客截获的报文就无法被直接看穿了，阿辉放心的将这套设计上线运行，两天后客服还是在不断收到盗号的投诉，阿辉眉头一紧看来事情并没有那么简单，这个黑客是有点水平的。 阿辉经过一天的分析得出结论，黑客应该是反编译了弱鸡APP的源代码，得到了源码中存储的约定密钥ACMYTE，得到密钥的黑客只需要不断代入市面上的加密算法即可获得明文结果。阿辉心想，既然持久化在APP端不安全，要不写在服务端用网络请求的方式下发到APP端？那这个获取密钥的请求被截获了怎么办？百思不解的阿辉请教了大学老师阿甘，阿甘提示可以使用非对称密钥进行加密，阿辉顺着思路开始了下一步的防护工作。 非对称密钥加密凭着阿辉快速的学习与理解能力，很快就搭建起了一套基于非对称密钥加密的通信方式 这套体系下黑客就算反编译了APP也无法去破解请求报文，但阿辉发觉所有的接口响应时间都变慢了不少，仔细分析阿辉找到问题所在，非对称密钥的加解密效率较低，造成了较差的用户体验。 这个问题并没有困扰阿辉太久，强大的融会贯通能力让他很快找到了合适的解决方案，上述两个方案的冲突点在于 对称密钥存在密钥泄漏风险 非对称密钥存在性能低下问题 何不把两者取长补短结合起来使用，当弱鸡APP登录时采用非对称密钥的交互方式，服务端下发token的同时附带一个与其关联的对称密钥，之后的业务交互都使用这个对称密钥加密进行。 阿辉心情激动的落地了这个思路并将其上线，并将实现思路与老师阿甘交流畅谈，阿甘听完后笑着说：你这是实现了一个HTTPS的协议流程呀。阿辉听后本着不重复造轮子的精神去了解了一下HTTPS协议的交互流程，发现确实和自己思路大致一样，看着自己实现的交互流程阿辉心想，我这种方案的确实现了需求，但是有几个很严重的缺陷 在业务层做加密而不放在传输层对业务代码的侵入性太强 以这种方式发布的服务无法做到普适性，难以推广使用 综上原因阿辉选择抛弃自主研发的“HTTPS”，开始在传输层改造自己的应用 启用HTTPS阿辉的部署架构是简单的Nginx+多Tomcat搭建而成的小型服务集群，在查阅了相关的文档说明后，阿辉开始了HTTPS的配置工作 使用 OpenSSL 生成 SSL Key 和 CSR 文件 修改 Nginx 的配置文件并重启 阿辉信心满满的将开启了HTTPS防护的弱鸡APP上了线，值得高兴的是根据客服的反馈盗号申诉的人明显减少，但有一个坏消息，*盗号情况却没完全消失，阿辉心想难道这套体系下还能被盗取密码么？难道我这体系还有漏洞…阿辉与黑客新一轮的周旋开始了。 中间人攻击黑客小刘自张三话费事件尝到甜头以后就一直在关注弱鸡APP，弱鸡APP在不断升级的同时小刘也在不断成长，小刘与阿辉的博弈让两人的水平都在不断攀升，今天小刘很高兴，因为他利用中间人攻击再次破解了阿辉的安全防线。 何为中间人攻击？ 中间人攻击(Man-in-the-MiddleAttack，简称“MITM攻击”)是指攻击者使用公钥交换的方式来拦截消息并转发取代它们，原始双方表面上看仍然互相通信，但是内容可能已经被窥探或篡改，其攻击流程如下所示 服务器向客户端发送公钥。 攻击者截获真实的公钥，保留在自己手上。 攻击者自己生成一个伪造的公钥，发给客户端。 客户端收到伪造的公钥后，使用此公钥加密对称密钥得到密钥密文发给服务器。 攻击者截获获密钥密文，用自己的私钥解密获得对称密钥，同时使用真实的公钥加密对称密钥发给服务器。 至此客户端与服务器通暴露的对称密钥进行通信，对于攻击者来说等同于明文通信。 不难理解中间人攻击是发生在服务器的证书的下发阶段，\b问题根本原因在于：客户端无法确定服务器下发的证书是否被中间人篡改？ CA体系阿辉经过查阅资料也了解到了中间人攻击，\b\b在了解到问题的根本原因后解决它变得简单了，只需要给弱鸡APP找到一个验证证书是否被篡改的方式即可，阿辉在网络上寻找解决方案，CA体系进入了阿辉的视野。 CA(Certificate Authority)是指提供可信证书的认证中心机构，它把用户的公钥和用户的其他标识信息（如名称、e-mail、身仹证号等）捆绑在一起，在互联网上验证用户的身份。 也就是说阿辉可以将弱鸡APP的证书与其标识信息在CA机构中注册，之后弱鸡APP获取服务器下发的证书后先去CA机构中验证证书的来源，确定来源可靠后再进行网络交互，这便防止了中间人攻击。 拓展其实不仅仅在网站交互中存在中间人攻击问题，只要是基于非对称加密的传输协议都会存在该问题，比如Linux服务器的登录认证是通过SSH协议来进行的，平常我们登录一个服务器的流程是这样的 &gt; ssh root@192.168.31.100 The authenticity of host 'host (192.168.31.100)' can't be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 系统会提示无法确定192.168.31.100公钥的真实性，只知道它的公钥指纹，是否还要继续连接？ 公钥指纹是代表对公钥MD5计算后的值，由于公钥的长度比较长不容易比对，便用这个较短的指纹值进行比较，为什么要比较，其实就是为了防止中间人攻击篡改掉公钥信息。而我们如何知道服务器的公钥指纹呢？这里也没有比较好的办法，一般情况下可以在网站公示或者采用密钥对登录。 当你输入yes后表示公钥被接受，它将被保存于$HOME/.ssh/known_hosts中作为信任的主机，再次连接时将跳过警告。 Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'host,192.168.31.100' (RSA) to the list of known hosts. Password: ****** 阿辉的心态🤔经过一连续的事件阿辉的心态有了明显的变化，它意识到系统的安全设计是一个很重要模块，在一些涉及资金的模块时更是要对其严格把关，检查设计、开发与部署方面是否存在安全漏洞。抱着这样的心态，阿辉准备重新审视并检查一遍弱鸡APP是否还存在其他的安全漏洞。 敏感信息防护阿辉先从弱鸡APP的数据库设计开始检查，结合自己最近获取到的安全知识阿辉很快就发现了系统用户表设计的有问题。 这样的设计虽然非常简单易懂，但是阿辉模拟了一下如果数据库信息泄漏了，那自己系统的所有用户数据不就完全公开了么，想想都令人害怕，看来得找个办法对脱库数据进行保护。 密文存储为了规避密码泄漏的风险，密码不应该明文存储在数据库中，那就转换成密文存储！阿辉立马想到两种手段 通过加密算法存储密码，用户登录时对接收到的密码做同样的加密然后对比数据库 通过hash（摘要）算法存储密码，用户登录时对接收到的密码做同样的hash然后对比数据库 对比两种方案后阿辉选择了后者，主要有以下两个原因 加密算法需要一个密钥，密钥的存储也是有泄漏风险的 密码不同于用户名称这样的字段，它没有转换明文这种需求并且它也不希望自己能被逆向转换，正好符合摘要算法的场景 经过改造后的系统用户数据如下所示 现在看来数据脱库后的风险似乎降了许多，但阿辉不多久又了解到一个名词，叫做密码字典，代指包括许多人们习惯性设置的密码的数据字典，比如Github就有一个叫做爆破字典的仓库，阿辉不禁心想，用户数据脱库后，人们可以通过密码字典来反向寻找与密码相匹配的用户，也能达到破解的效果（如果用户密码设置的不复杂），破解的思路如下 遍历密码字典，从密码字典中取出一条密码，对其做hash算法得到密码摘要 使用密码摘要作为条件查询数据库的信息便可找到以此为密码的账户列表 可见这种设计方式如果数据库中存在相同密码的用户，一次查询匹配可以将它们全部获取，这对破解者也太友好了，看来方案还得改改。 加盐存储阿辉经过搜索很快就得到了一种更好的方案，也就是加盐存储，阿辉修改了系统用户的表结构，给它增加了一个字段叫做salt（盐值），这个盐值需要随机生成并且尽量保证每个用户都不一样，password密码字段中存储也不再只是对密码的hash了，而是hash(password+salt)，数据表变成了如下结构 在用户登录时验证流程如下 获取用户提交的密码submitPassword与其数据库中存储的盐值salt 判断hash(submitPassword+salt)是否与数据库中存储的密码password相等 流程改造后并不复杂，重点是salt怎么让数据更加安全的呢？我们先来看看破解的流程 遍历密码字典，从密码字典中取出一条密码 遍历用户数据表取salt字段拼接到密码后面形成新的字符串，hash后与密码字段匹配 这个破解流程和上面的未加盐值的破解流程最大的区别是，相同密码的用户不会被一次性获取到了，增加了暴力破解的复杂度。 我们假设密码字典有20W条数据，弱鸡APP有100W个用户，那么完全覆盖需要匹配多少次呢？ 不难算出，匹配次数为20Wx100W，也就是说最多需要2000亿次可得到密码字典覆盖到的用户，这个运算量的成本已经非常高了，而且在设计的时候也不一定就把盐值放在密码之后hash，也可以放到前面或者中间，由于破解者不知道盐值与密码的组成方式，这会给破解带来更大的难度。 这个设计暂时成为了阿辉满意的方案，除了数据方面，阿辉还去了解了一下其他可能出现的安全漏洞，并做了以下总结 安全漏洞防护SQL-注入SQL注入攻击是将击是输入参数未经过滤，直接拼接到SQL语句当中解析，执行达到预想之外的一种行为。比如下方的函数就存在sql注入风险，示例中通过传递参数的方式把sys_user表删除了。 public SysUser findUserByAccount(String account) { String sql = &quot;select * from sys_user where account = &quot; + account; execute(sql); } public static void main(String[] args) { String account = &quot;'';drop table sys_user;&quot; findUserByAccount(account); // select * from sys_user where account = '';drop table sys_user; } 阿辉看了看自己的系统，使用hibernate作为持久层且没有任何SQL拼接的操作，框架会帮系统防止SQL注入，放下心来，日后再去阅读框架是怎么去防止SQL注入的。 XSS-攻击XSS攻击通过在目标网站上注入恶意脚本并运行，盗取用户的令牌信息。比如系统有一块公共评论展示区，有一个用户留下了JS脚本alert('123')，网站如果没有做XSS过滤那么在评论渲染时脚本就会被执行，只要打开这个评论区的用户就会弹出一个123的提示框，如果用户留下的是一个盗用token并将其发到自己服务器，那么它就可以伪装成其他用户进行操作。 CSRF-攻击CSRF攻击与XSS攻击不同之处在于，XSS盗取了令牌信息，但是CSRF没有盗取，它诱导用户点击链接去访问用户曾经认证过的网站并运行一些操作，详见跨站请求伪造wiki 总结网络安全是一个日益火热的话题，这些知识作为一项软技能虽然不能给我们的开发带来大的帮助，但却是很重要且不可或缺的一块知识。 写这篇文章的目的一来给自己所了解到的安全知识做一个总结，第二也希望文章能够对想了解这块内容的人提供一些帮助，文章的编写借鉴了网上部分优秀文章的内容，都在下方的参考资料中，同样希望这些优秀博文能够帮助到想要了解这块内容的同学们。共勉。 参考资料 Web系统权限控制如何设计 权限系统与RBAC模型概述 RBAC权限管理 什么是中间人攻击？——知乎 SSH原理与运用（一）：远程登录 Nginx 配置 HTTPS 服务器 为什么要在密码里加点“盐” WEB应用常见15种安全漏洞一览","link":"/2019-12-14-safe-on-web/"},{"title":"随笔——如何防止空指针","text":"&emsp;&emsp;很久没写博客啦，因为前段时间公司项目忙着上线（绝对不是因为懒！），公司事为大，现在稍微闲了点，整点随笔写写别荒废了自个的写作能力。今天的主题是空指针，这玩意儿在咱们的开发生涯中应该是出现最多的异常吧，今天我就讲讲如何在程序中有效的防止该异常的出现。 前言最近读了一篇有意思的博客叫做空指针漫谈，里面标注的原文链接已经失效了，所以我链了转载的地址。这篇博客讲述了空指针设计的起源（没想到原因仅仅是因为空指针的实现简单而已！），并在后续给出了一些放空指针异常的解决方案，所以今天我就针对如何在Java语言中有效的防止空指针这个问题展开讨论，本文基于JDK1.8进行讲述。 为何产生空指针从程序的角度null作为程序的一个特殊状态，在Java中，除了基本类型以外的所有引用类型都可以赋值为null，如果变量的值为null，那么接下来用它调用成员函数式便会抛出空指针异常 public class NullPointTest { public static void main(String[] args) { List&lt;String&gt; strList = null; // NullPointException System.out.println(strList.size()); } } 从人为的角度其实判断代码是否可能出现空指针并给出健壮性的代码不难实现，只需要先判非空再调用即可，但是就如空指针漫谈此文所说 在某些地方，程序员可能会觉得某个变量从逻辑上可以保证它不会为空，于是就省略掉了空指针检查。可是，时过境迁之后，因为代码的各种变化，导致这样的前提不再成立的时候，空指针异常就发生了，代码因此非常脆弱。而有些谨慎的程序员，为未雨绸缪计，会在各个地方都加上保护性的空指针检查，又让代码变得非常臃肿。 总结来说就是空指针判断全加代码臃肿，不加代码脆弱，极端的方式并不能很好的解决此问题，我们要寻求一种合理的解决方式。 解决方案更安全的使用API这部分就是一些日常开发经验了，比如str.equals(&quot;abc&quot;)与&quot;abc&quot;.equals(str)实现的效果相同，但是后者不存在空指针异常的可能性，同理的还有str.toString()与String.valueOf(str)等等，这部分技巧的掌握程度跟你的踩坑经验成正比，坑踩多了当然就记住了。 使用空注释@NonNull与@Nullable两个注解可以告诉IDE此位置你是否允许空值出现，他支持使用在以下位置 方法参数 方法返回 局部变量 字段 这种约定式设计可以让调用者有责任不传递空值，通过@NonNull也可以告诉调用者此处可以不做空值校验请大胆使用，代码时过境迁之后维护者看到此注解也能明白此方法需要保持其逻辑返回不可为空 使用Optional包装结果Optional类是Java8提供的一个新特性，它是为了解决空指针异常而引入的，而且，它是基于函数式风格设计的。首先我们来看看它是怎么解决空指针的呢？且听我娓娓道来 如何防空？给空对象做一个包装，什么叫做给空对象做一个包装？看看下面的代码 这里定义了一个ValueWarp类用于包装函数的响应结果，randomNullContentWarp函数负责随机返回带有空内容的值包装而不直接返回空对象，main函数中循环调用此函数打印内容，这里我将重点讲一下ValueWarp中以下三个函数的设计 get：获取包装内容，内容不存在时抛出NoSuchElementException异常 orElse：获取包装内容，当包装内容不存在时采用用户传入的备选内容 ifPresent：当包装内容不为空时调用用户传入的内容消费行为，这里用到了一个java8函数式编程库中的Consumer接口，相关说明在如何优雅的遍历树结构这篇博客中有讲到 其实get方法并不能很好的防止由于空指针带来的异常问题，而orElse与ifPresent则可以防止此问题出现，最佳的实践方式应该是当你有备选值时使用orElse函数，当你只是想非空时执行则使用ifPresent函数，如上述例子中的warp.ifPresent(o -&gt; System.out.println(o));代表非空时打印包装内容 回到Optional类，我们看看它的代码 代码不多且不是很难懂，很多api都是以函数式的风格去设计的，确实其中部分api很适合用函数式的风格，为什么呢？举个例子，下述代码循环调用了一个可能产生空对象的函数，并打印符合数字大于3这个条件的字符串I am ${数字内容} 这段代码简洁性不用多说，并且不需要考虑包装内容为空的情况，因为包装类已经给你内部统一好了处理逻辑，你可以把防空判断给去除，将代码重心放到业务上 总结看到这里我想你对如何防止空指针已经有了一些思路了，总结来说分了三方面去防护 对于明确了非空的位置使用@NonNull注释来告知维护/调用者 对于不明确返回是否可空的函数使用Optional进行包装后返回，调用者可通过ifPresent方法来进行非空调用 对于字符串类型可以更安全的去使用部分API 最后，祝愿大家以后的代码永远没有空指针！ 参考资料 空指针漫谈 使用空注释——IBM Java函数式开发——优雅的Optional空指针处理","link":"/2019-11-20-null-for-java/"},{"title":"随笔——Java SPI、Dubbo与SpringBoot","text":"&emsp;&emsp;在平时的自我学习中，总结归纳能力是非常重要的，使用已有的知识体系去预测未知的领域，然后再进行不断的自我修正，个人认为这是个不错的学习方法。今天我们就总结归纳一下如题的三块知识体系，寻找它们的共性与区别。 前言SPI是什么&emsp;&emsp;SPI全称service provider interface是JDK中内置的服务发现机制，如何来理解这个服务发现机制，做Java开发的必然或多或少都了解Spring框架以及它的周边生态，Spring很好的利用工厂模式+配置文件实现了IoC容器，让Java Bean的实例化由硬编码变成了可配置，这是个解耦的操作，那服务发现机制它的目的是什么，它其实是一种Java Bean的动态替换发现的机制，类比Spring你就会发现他们解决的问题是一样的，都是为了让程序能够消除部分的硬编码。 什么是硬编码&emsp;&emsp;为了能够更加深入的理解SPI机制，我们可能需要先明白硬编码是什么？为什么程序中要尽可能消除硬编码？在这里可以参考我的这篇文章：详解控制反转 SPI的使用场景 数据库驱动加载接口实现类的加载，JDBC加载不同类型数据库的驱动 日志门面接口实现类加载，SLF4J加载不同提供商的日志实现类 Spring中大量使用了SPI，比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等 Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，以解决原生SPI带来的部分副作用 Java-SPI&emsp;&emsp;我们都知道Spring是以xml的形式配置Java Bean，然后通过解析此文件完成Bean的实例化，Java SPI做的事情是类似的，它将读取META-INF/services目录下的文件，文件名称是接口的全限定名，内容为该接口实现类的权限定名，举个SPI的使用示例 先定义一个接口与一组实现类如下 package com.exp.spi; public interface IService { String getServiceName(); } public class MenuService implements IService { @Override public String getServiceName() { return &quot;菜单服务&quot;; } } public class UserService implements IService { @Override public String getServiceName() { return &quot;用户服务&quot;; } } 在 src/main/resources/ 下建立 /META-INF/services 目录，新增文件com.exp.spi.IService内容如下 com.exp.spi.MenuService com.exp.spi.UserService 使用 ServiceLoader 来加载配置文件中指定的实现 public class SPIMain { public static void main(String[] args) { ServiceLoader&lt;IService&gt; services = ServiceLoader.load(IService.class); for (IService s : services) { System.out.println(s.getServiceName()); } } } 运行此程序将会输出以下内容 菜单服务 用户服务&emsp;&emsp;看到这里你会发现这是不是特别像SpringBoot中我们定义的自动化配置文件META-INF/spring.factories，这里面写的也是自动化配置类的全限定名，其实它的实现原理和Java SPI是一样的，在了解SpringBoot SPI之前我们先来看看Java SPI的实现原理。 从入口函数来看很容易找到核心类，查看ServiceLoader源码如下 &emsp;&emsp;代码量不多，我们主要来读一下load方法因为我们的例子中就是调用的它，可以看到它指向了构造函数，而构造函数调用了reload方法最终返回了一个迭代器 &emsp;&emsp;迭代器负责在遍历时调用newInstance方法构造配置文件中的接口实现类，所以这也要求实现类必须要有一个无参构造，由于返回的是一个迭代器，如果你只想使用其中一个类，比如我们的例子中你只想用UserService，你必须要遍历全部的服务才能筛选出你要的那个类，而这么做全部的实现类都将被实例化，造成了资源的浪费，正是因为这些副作用的存在，很多框架才去实现了自己的SPI。 SpringBoot-SPI&emsp;&emsp;SpringBoot的SPI机制由spring-core工程中的org.springframework.core.io.support.SpringFactoriesLoader实现，源码如下，代码比较简单就不做过描述了，这里要讲的是如果能在看到并且理解了Java SPI的时候就关联到了SpringBoot的自动化配置原理，就拥有了举一反三的学习能力，这才是最重要的。 小结-SPI&emsp;&emsp;看到这里其实都能够清楚知道SPI的大概用法与应用场景，刚才我们也说到Java SPI的一个缺点就是无法做到按需加载，那么它还有没有别的缺点。 回到最初的例子，基于IService我们设计了UserService与MenuService，假设现在我有一个需求要在UserService中去调用MenuService的服务，使用Java SPI就无法实现动态注入的功能，那么SpringBoot SPI有没有对动态注入的功能提供支持呢？我们不妨看看代码 不难发现这里也是调用newInstance方法来完成实例化的，所以也需要有一个无参构造函数，所以不能通过构造函数做参数注入，但是我们写自动化配置类的时候是可以使用注解完成Java Bean的动态注入的，这里的蹊跷之处有兴趣的同学可以自己去挖一挖，在有了入口并了解了Spring的核心组件的前提下，这一部分并不难懂，这也是在学习上举一反三的好时候。 Dubbo-SPI&emsp;&emsp;有关Dubbo SPI它的实现就较为复杂了，它的配置与上面讲的方式也稍有不同，比如我们的例子的配置需要更改成 menuService=com.exp.spi.MenuService userService=com.exp.spi.UserService 不难看出这是个键值对的配置方式，等号左边是该服务的key，右边为服务的全限定名，关于Dubbo SPI的具体说出可以参考Dubbo 之于 SPI 扩展机制的实现分析这篇文章，因为他讲的比我好，溜了 参考资料 理解的Java中SPI机制 Dubbo 之于 SPI 扩展机制的实现分析 JDK和Spring中SPI的实现原理和区别","link":"/2019-09-01-spi-spring-dubbo/"},{"title":"随笔——如何优雅的遍历树结构","text":"&emsp;&emsp;在编程生涯中我们会碰上各式各样的数据结构，简单的如数组、列表、字典，复杂一点的如树结构、图等等，本文将基于Java8讲述如何优雅的实现树的遍历、打印、平铺、聚合操作。 树结构描述&emsp;&emsp;本文围绕的树结构大体样例如下所示，这种结构常用于我们Web系统的菜单数据结构的存储，在数据库我们一般是平铺存储，但是使用时需要聚合成树状结构，在平时的实体设计中，关于子项的key不一定就叫childrens，所以本文最终设计的工具类也需要设计的更为通用 private Integer id; private String name; private Integer parentId; private List&lt;Node&gt; childrens; 常用的遍历方式递归public static void traversing(List&lt;Node&gt; root) { for (Node node : root) { List&lt;Node&gt; childres = node.getChildrens(); if (childres != null &amp;&amp; childres.size() &gt; 0) { traversing(childres); } } } 栈public static void traversing(List&lt;Node&gt; root) { Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); root.forEach(stack::push); while (!stack.isEmpty()) { Node o = stack.pop(); List&lt;Node&gt; childrens = o.getChildrens(); if (childrens != null &amp;&amp; childrens.size() &gt; 0) { childrens.forEach(stack::push); } } } 如何通用思考&emsp;&emsp;要做到工具通用就要考虑哪一块是变化的部分，在我们的树结构实体模型中有几个核心的字段，这几个字段每个人在设计自己业务模型中都可能不一样，但却是必然存在的 子节点字段 节点ID字段 父节点ID字段 需要统一这种变化的部分我们一般会有两种解决办法 建立一个TreeNode接口，写上三个函数让用户设计实体时必须去实现此接口才能用你的工具类 利用函数式编程的思想将这几个获取操作抽象成参数传递，显然，这种办法对用户来说是更加友好的，所以我们这次会基于此方案来实现工具类 在实现之前我们需要先了解一下Java中的函数式编程接口 Java8-function-api介绍Java8的java.util.function包下提供了很多支持函数式编程的类，可以帮我们很好的抽象变化的部分，我们先看一下function api的归纳，Java8主要提供了以下类来支持函数式编程，其中标了重点的是这次编写工具所使用到的类。 类 描述 BiConsumer&lt;T,U&gt; 代表了一个接受两个输入参数的操作，并且不返回任何结果 BiFunction&lt;T,U,R&gt; 代表了一个接受两个输入参数的方法，并且返回一个结果 BinaryOperator 代表了一个作用于于两个同类型操作符的操作，返回了操作符同类型的结果 BiPredicate&lt;T,U&gt; 代表了一个两个参数的boolean值方法 BooleanSupplier 代表了boolean值结果的提供方 Consumer 代表了接受一个输入参数并且无返回的操作 DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果 DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果 DoubleFunction 代表接受一个double值参数的方法，并且返回结果 DoublePredicate 代表一个拥有double值参数的boolean值方法 DoubleSupplier 代表一个double值结构的提供方 DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果 DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果 DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double Function&lt;T,R&gt; 接受一个输入参数，返回一个结果 IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int IntConsumer 接受一个int类型的输入参数，无返回值 IntFunction 接受一个int类型输入参数，返回一个结果 IntPredicate 接受一个int输入参数，返回一个布尔值的结果 IntSupplier 无参数，返回一个int类型结果 IntToDoubleFunction 接受一个int类型输入，返回一个double类型结果 IntToLongFunction 接受一个int类型输入，返回一个long类型结果 IntUnaryOperator 接受一个参数同为类型int,返回值类型也为int LongBinaryOperator 接受两个参数同为类型long,返回值类型也为long LongConsumer 接受一个long类型的输入参数，无返回值 LongFunction 接受一个long类型输入参数，返回一个结果 LongPredicate 接受一个long输入参数，返回一个布尔值类型结果 LongSupplier 无参数，返回一个结果long类型的值 LongToDoubleFunction 接受一个long类型输入，返回一个double类型结果 LongToIntFunction 接受一个long类型输入，返回一个int类型结果 LongUnaryOperator 接受一个参数同为类型long,返回值类型也为long ObjDoubleConsumer 接受一个object类型和一个double类型的输入参数，无返回值 ObjIntConsumer 接受一个object类型和一个int类型的输入参数，无返回值 ObjLongConsumer 接受一个object类型和一个long类型的输入参数，无返回值 Predicate 接受一个输入参数，返回一个布尔值结果 Supplier 无参数，返回一个结果 ToDoubleBiFunction&lt;T,U&gt; 接受两个输入参数，返回一个double类型结果 ToDoubleFunction 接受一个输入参数，返回一个double类型结果 ToIntBiFunction&lt;T,U&gt; 接受两个输入参数，返回一个int类型结果 ToIntFunction 接受一个输入参数，返回一个int类型结果 ToLongBiFunction&lt;T,U&gt; 接受两个输入参数，返回一个long类型结果 ToLongFunction 接受一个输入参数，返回一个long类型结果 UnaryOperator 接受一个参数为类型T，返回值类型也为T 工具类设计 利用Function&lt;T,R&gt;来抽象子节点/节点Key/节点父节点Key的获取逻辑 利用Consumer&lt;T&gt;来抽象遍历到节点后的逻辑操作，比如打印/插入其他数据结构 利用BiConsumer&lt;T,U&gt;来抽象节点的写入操作，如聚合树时的子节点写入操作 节点遍历方面使用栈来实现，防止在树结构深度比较大时爆栈 /** * @author JianhuiChen * @description 树状结构工具类 提供通用树结构的平铺/聚合方法 * @date 2019-08-29 */ public class TreeUtil { /** * 遍历树结构 * * @param root 节点树结构 * @param loadChildrenNodes 加载树的子节点列表函数 接收一个节点 返回节点的子结构 * @param behavior 遍历到的节点行为 * @param &lt;T&gt; 树节点对象 */ public static &lt;T&gt; void traversing(List&lt;T&gt; root, Function&lt;T, List&lt;T&gt;&gt; loadChildrenNodes, Consumer&lt;T&gt; behavior) { Stack&lt;T&gt; stack = new Stack&lt;&gt;(); root.forEach(stack::push); while (!stack.isEmpty()) { T o = stack.pop(); behavior.accept(o); List&lt;T&gt; childrens = loadChildrenNodes.apply(o); if (childrens != null &amp;&amp; childrens.size() &gt; 0) { childrens.forEach(stack::push); } } } /** * 平铺树结构 * * @param root 节点树结构 * @param loadChildrenNodes 加载树的子节点列表函数 接收一个节点 返回节点的子结构 * @param &lt;T&gt; 树节点对象 * @return 平铺结构 */ public static &lt;T&gt; List&lt;T&gt; tileTree(List&lt;T&gt; root, Function&lt;T, List&lt;T&gt;&gt; loadChildrenNodes) { List&lt;T&gt; list = new ArrayList&lt;&gt;(); traversing(root, loadChildrenNodes, list::add); return list; } /** * 打印树信息 * * @param list 树结构列表 * @param loadChildrenNodes 加载树的子节点列表函数 接收一个节点 返回节点的子结构 * @param &lt;T&gt; 树节点对象 */ public static &lt;T&gt; void printTree(List&lt;T&gt; list, Function&lt;T, List&lt;T&gt;&gt; loadChildrenNodes) { System.out.println(&quot;---------- Tree Nodes Print ----------&quot;); traversing(list, loadChildrenNodes, System.out::println); System.out.println(&quot;---------- Tree Nodes Print ----------&quot;); } /** * 聚合树结构 * * @param list 节点列表结构 * @param loadKey 节点唯一key读取 接收一个节点 返回节点的唯一key * @param loadParentKey 节点父节点key读取 接收一个节点 返回节点的父节点key * @param write 节点子项写入函数 接收待写入节点与节点子项 负责将子节点写入 * @param &lt;T&gt; 节点对象 * @param &lt;R&gt; 节点唯一key对象 * @return 树结构 */ public static &lt;T, R&gt; List&lt;T&gt; polymerizationTree(List&lt;T&gt; list, Function&lt;T, R&gt; loadKey, Function&lt;T, R&gt; loadParentKey, BiConsumer&lt;T, List&lt;T&gt;&gt; write) { List&lt;T&gt; root = list.stream().filter(o -&gt; loadParentKey.apply(o) == null).collect(Collectors.toList()); Stack&lt;T&gt; stack = new Stack&lt;&gt;(); root.forEach(stack::push); while (!stack.isEmpty()) { T o = stack.pop(); R key = loadKey.apply(o); List&lt;T&gt; childrens = list.stream() .filter(k -&gt; key.equals(loadParentKey.apply(k))) .collect(Collectors.toList()); write.accept(o, childrens); if (childrens.size() &gt; 0) { childrens.forEach(stack::push); } } return root; } public static void main(String[] args) { List&lt;Node&gt; listNodes = new ArrayList&lt;&gt;(); listNodes.add(new Node(1, &quot;根节点1&quot;, null)); listNodes.add(new Node(2, &quot;根节点2&quot;, null)); listNodes.add(new Node(3, &quot;根节点3&quot;, null)); listNodes.add(new Node(4, &quot;1-1&quot;, 1)); listNodes.add(new Node(5, &quot;1-2&quot;, 1)); listNodes.add(new Node(6, &quot;2-1&quot;, 2)); listNodes.add(new Node(7, &quot;3-1&quot;, 3)); listNodes.add(new Node(8, &quot;1-1-1&quot;, 4)); listNodes.add(new Node(9, &quot;1-1-2&quot;, 4)); printTree(listNodes, Node::getChildrens); // 聚合 List&lt;Node&gt; treeNodes = polymerizationTree(listNodes, Node::getId, Node::getParentId, Node::setChildrens); printTree(treeNodes, Node::getChildrens); // 平铺 listNodes = tileTree(treeNodes, Node::getChildrens); printTree(listNodes, Node::getChildrens); } private static class Node { private Integer id; private String name; private Integer parentId; private List&lt;Node&gt; childrens; public Node(Integer id, String name, Integer parentId) { this.id = id; this.name = name; this.parentId = parentId; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getParentId() { return parentId; } public void setParentId(Integer parentId) { this.parentId = parentId; } public List&lt;Node&gt; getChildrens() { return childrens; } public void setChildrens(List&lt;Node&gt; childrens) { this.childrens = childrens; } @Override public String toString() { return &quot;Node{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + '}'; } } }","link":"/2019-08-29-essay/"},{"title":"Shell学习与归纳","text":"&emsp;&emsp;作为一个后端开发工程师在工作中不可能不与Linux服务器打交道，应用的部署测试，中间件的环境搭建，搭建个人的博客，甚至玩玩树莓派这些比较冷门的单片机计算机都离不开Linux指令与Shell编程，本文就来学习与归纳一些我个人用到的Linux指令与Shell语法并给出示例，本文只讲基础，细枝末节将另起博文详细分析。 Shell语法归纳变量与参数变量定义与引用#!/bin/sh str=&quot;My name is JianhuiChen.&quot; echo ${str} str=&quot;Reset my name&quot; echo ${str} unset str echo ${str} 参数引用#!/bin/sh echo &quot;第一个参数为：$1&quot; echo &quot;第二个参数为：$2&quot; echo &quot;传递到脚本的参数个数为：$#&quot; echo &quot;所有向脚本传递的参数为：$*&quot; echo &quot;脚本运行的当前进程ID号为：$$&quot; echo &quot;后台运行的最后一个进程的ID号为：$!&quot; echo &quot;所有向脚本传递的参数为：$@&quot; echo &quot;Shell使用的当前选项为：$-&quot; echo &quot;最后命令的退出状态为：$?&quot; 逻辑判断、循环与分支选择逻辑判断#!/bin/sh x=5 y=10 z=20 # if then echo &quot;if then command&quot; if [ $x != $y ] then echo &quot;$x != $y&quot; echo &quot;Print again $x == $y&quot; fi # if else echo &quot;if else command&quot; if [ $x != $y ] then echo &quot;$x != $y&quot; echo &quot;Print again $x != $y&quot; else echo &quot;$x == $y&quot; fi # if else-if else echo &quot;if else-if else command&quot; if [ $x == $y ] then echo &quot;$x == $y&quot; elif [ $y == $z ] then echo &quot;$x != $y and $y == $z&quot; else echo &quot;$x != $y and $y != $z&quot; fi 循环#!/bin/sh # Define array arr=(1 2 3 4 5) # For loop echo &quot;For loop&quot; for var in ${arr[*]} do echo &quot;$var&quot; done # While loop echo &quot;While loop&quot; i=0 while (( $i &lt; ${#arr[*]} )) do echo &quot;${arr[$i]}&quot; let &quot;i++&quot; done # Break and continue echo &quot;Break and continue&quot; j=0 while [[ $j &lt; ${#arr[*]} ]] do if [ $j == 3 ] then echo &quot;Break in ${arr[$j]}&quot; break elif [ $j == 1 ] then echo &quot;Dump ${arr[$j]}&quot; let &quot;j++&quot; continue else echo &quot;Print ${arr[$j]}&quot; fi let j++ done 分支选择#!/bin/sh x=3 case $x in 1) echo 'Case 1' ;; 2) echo 'Case 2' ;; 3) echo 'Case 3' ;; 4) echo 'Case 4' ;; *) echo 'Default' ;; esac 输出重定向#!/bin/sh export BIN_PATH=$(cd `dirname $0`;pwd) echo BIN_PATH:[$BIN_PATH] # 输出重定向到文件 &gt;&gt; 代表追加 nohup ping 127.0.0.1 &gt; exec.log 2&gt;&amp;1 &amp; echo [if you want stop app, can run] kill -9 $! echo [if you want search logs, can run] tail -f $BIN_PATH/exec.log 第一次看到nohup ping 127.0.0.1 &gt; exec.log 2&gt;&amp;1 &amp;这条语句的同学可能会有点懵逼，在这里我们一段一段来理解这条语句 nohub：当前进程退出后运行程序不退出，也就是后台运行 ping 127.0.0.1：具体执行的语句，这句就不过多解释了 &gt; exec.log：将语句执行的结果输出到shell脚本同级目录的exec.log文件，采用覆盖的模式，如果是追加输出可使用&gt;&gt;替换&gt; 2&gt;&amp;1：这句可能会复杂点，意思是将标准错误等效于标准输出，其中&amp;起到了等效的作用 0 表示stdin标准输入 1 表示stdout标准输出 2 表示stderr标准错误 最后一个&amp;：这个是配合nohub使用的，意思是在脚本的结尾让程序自动运行，没有此指令脚本运行会卡在nohub处需要按一下任意键才可继续执行 Linux指令与常用库归纳文件与目录 ls：列表显示文件与目录信息 tree：树形显示文件与目录信息 cd：切换目录 mkdir：创建目录 pwd：以绝对路径的方式显示用户当前工作目录 cp：拷贝文件 rm：删除文件 mv：移动文件 diff：比较文件差异 chmod：文件授权 cat：查看文件内容 head：显示文件的头几行 tail：显示文件的后几行 touch：创建一个新文件 tar：压缩与解压缩 sed：非交互式文本编辑 vi：交互式文本编辑，按i插入文本编辑文件，按ESC输入指令退出 :w：写入文件 :w!：不询问方式写入文件 :wq：保存并退出 :q：退出, :q!：不保存退出 完成下面的语句对你记忆这些基础指令会有帮助 #!/bin/sh # 查看当前工作目录与其结构 pwd ls tree # 创建一个目录 test-dir mkdir test-dir # 进入此目录 cd test-dir # 创建一个文件 README.md touch README.md # 编辑文件插入一些内容 vi README.md # 查看内容 cat README.md # 查看文件的前两行 head -n2 README.md # 循环读取文件的后三行 tail -n3 -f README.md # 复制 README.md 到同级目录 README-COPY.md cp README.md README-COPY.md # 修改 README-COPY.md 的内容 vi README-COPY.md # 与原文件比较差异性 diff README.md README-COPY.md # 移动 README.md 到上一级目录 mv README.md .. # 删除上一级目录的 README.md rm ../README.md # 将 README-COPY.md 重命名为 README.md mv README-COPY.md README.md # 授予 README.md 权限 chmod +x README.md # 压缩 test-dir 目录 cd .. tar -czvf test-dir.tar.gz test-dir # 删除 test-dir 目录 建议使用参数 -i 进入询问模式 rm -rf test-dir # 解压 test-dir.tar.gz tar -xzvf test-dir.tar.gz 网络与常用库 ifconfig：查看网络网卡信息 netstat：显示网络状态，查看网络端口或者路由信息 lsof：用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP) ping：不多说了 telnet：执行远程登录，可用测试网络端口链路是否通畅 ssh：使用ssh协议远程登录主机 scp：用于Linux之间复制文件和目录 ftp：基于ftp协议的文件传输指令 wget：网络下载器 curl：http命令行工具 系统 shutdown：关机 reboot：重启 mount：挂在次盘/文件系统 umount：卸载磁盘/文件系统 exit：退出当前终端 last：显示最近一次登录的用户 history：显示输入过的历史指令 ps：列出系统中当前运行的进程 top：实时显示系统资源的使用情况 free：显示内存使用情况 quota：显示磁盘使用情况 kill：中止一个进程 uname：显示操作系统相关信息的命令 du：计算磁盘空间的使用情况 df：报告文件系统磁盘空间的使用情况 su：切换身份","link":"/2019-08-25-learn-shell/"},{"title":"Vue+SpringBoot单jar部署","text":"&emsp;&emsp;在前后端分离的开发模式中，到项目的打包发布阶段我们一般都是会采用一个支持HTTP动静分离的中间件来部署前后端应用，最常见的就是Nginx，它不仅可以帮我们做动静分离，还可以做后端请求的负载均衡，这一部分的实现教程很多在此就不做过多解释，本文想讲的是如何不依赖中间件，将前端打包的内容嵌入后端，以一个jar发布。 思考&emsp;&emsp;本人是基于SpringBoot+Vuejs来做前后端分离开发的，所以本次也基于这两个技术展来思考如何实现，在想如何不依赖中间件实现部署时我们得先思考中间件为我们的前后端分离部署带来了什么？ &emsp;&emsp;以Nginx举例，如下是前后端分离部署模式下的一个配置示例主要干了三件事情 使用alias实现静态资源的分发 使用try_files实现前端路由的转发，如http://localhost/home这个地址是对应不到静态资源的，这个时候就会触发404响应，try_files指令在对应不到静态资源时将内容转发到/index.html也就是前端首页，以此来实现history模式的前端路由 使用proxy_pass实现后端请求的分发 location /front { alias $application_path/traffic-sso/html; try_files $uri $uri/ /index.html last; index index.html index.htm; } location /api/ { proxy_pass http://localhost:8080/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } &emsp;&emsp;在知道中间件完成的核心功能后，我们需要基于SpringBoot项目也去完成这么一套功能，即可实现集成部署了，我们现在一项一项功能分析一下 静态资源的分发：可通过配置静态文件映射来实现 前端路由的转发：可通过拦截器来实现 后端请求的分发：可通过拦截器来实现 &emsp;&emsp;总体来说实现上不是什么问题，静态文件映射配置很容易在此不做过多描述，问题主要在拦截器的实现，需要有两个拦截器分别实现以下两个分发 http://localhost:8080/front/** =&gt; index.html http://localhost:8080/api/** =&gt; http://localhost:8080/** 代码实现&emsp;&emsp;观察上面拦截器其实主要就是实现一个路径匹配与处理器转发的功能，基于此需求我们定义RewriteFilter.java如下，这里使用Spring Web MVC的AntPathMatcher来做路径匹配器，使用了Java8的Function来做转发逻辑定义，代码比较简单就不做过多描述了 /** * @author JianhuiChen * @description 基于转发逻辑的过滤器 * @date 2019-08-15 */ public class RewriteFilter implements Filter { private Logger log = LoggerFactory.getLogger(RewriteFilter.class); /** * 配置url通配符 */ private final String urlPattern; /** * 转发逻辑 */ private final Function&lt;HttpServletRequest, String&gt; rewriteHandler; /** * 路径匹配器 */ private AntPathMatcher pathMatcher = new AntPathMatcher(); public RewriteFilter(String urlPattern, Function&lt;HttpServletRequest, String&gt; rewriteHandler) { this.urlPattern = urlPattern; this.rewriteHandler = rewriteHandler; } @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) req; String servletPath = request.getServletPath(); String context = request.getContextPath(); // 匹配的路径重写 if (pathMatcher.match(urlPattern, servletPath)) { String rewritePath = rewriteHandler.apply(request); log.debug(&quot;Rewrite {} to {}&quot;, servletPath, rewritePath); String fullPath; if (rewritePath.startsWith(&quot;/&quot;)) { fullPath = context + rewritePath; } else { fullPath = context + &quot;/&quot; + rewritePath; } req.getRequestDispatcher(fullPath).forward(req, resp); } else { chain.doFilter(req, resp); } } } &emsp;&emsp;现在我们将静态资源与拦截器配置使用 首先运行前端项目的打包指令将打包的静态资源拷贝到SpringBoot的public/static/resources目录下 配置前端路由的转发拦截器 /** * 匹配路由转发 * 所有 /front/** 请求映射至 /index.html * exp /front/home -&gt; /index.html */ @Bean public FilterRegistrationBean frontFilter() { FilterRegistrationBean&lt;RewriteFilter&gt; registration = new FilterRegistrationBean&lt;&gt;(); registration.setFilter(new RewriteFilter(&quot;/front/**&quot;, http -&gt; &quot;index.html&quot;)); registration.addUrlPatterns(&quot;/front/*&quot;); registration.setName(&quot;frontFilter&quot;); registration.setOrder(1); return registration; } 配置后端路由的转发拦截器 /** * 匹配动态请求 * 所有 /api/** 请求映射至 /** * exp /api/resources/users/me -&gt; /resources/users/me */ @Bean public FilterRegistrationBean apiFilter() { FilterRegistrationBean&lt;RewriteFilter&gt; registration = new FilterRegistrationBean&lt;&gt;(); registration.setFilter(new RewriteFilter(&quot;/api/**&quot;, http -&gt; http.getServletPath().replaceFirst(&quot;/api&quot;, &quot;&quot;))); registration.addUrlPatterns(&quot;/api/*&quot;); registration.setName(&quot;apiFilter&quot;); registration.setOrder(1); return registration; } 测试&emsp;&emsp;打开浏览器输入链接http://localhost:8080/front完成测试 其他AntPathMatcher相关记录&emsp;&emsp;AntPathMatcher是Spring用于路径匹配的工具类，我们经常写的@RequestMapping的匹配逻辑就与它有关，它主要的匹配模式有以下三种 ? 匹配任何单字符 * 匹配0或者任意数量的字符 ** 匹配0或者更多的目录 &emsp;&emsp;AntPathMatcher采用最长匹配原则，如/api/**与/api/resources/**来匹配/api/resources/users/me，后者会被成功匹配","link":"/2019-08-15-server-front-separate-package/"},{"title":"海岛寻宝问题","text":"&emsp;&emsp;5个人去一个海岛寻宝，最后一共找到了100枚金币。他们约定了一个分配方案，如下：五个海盗按照抽签的顺序依次提出方案，某一个人提出方案之后，剩余存活的人投票表决：方案需要获得超过半数人的认可之后才能被通过，否则方案提出者将会被扔进大海喂鲨鱼，某一个方案被通过后游戏就结束。注：每个人的投票都是在追求自己利益的最大化：保证自己不会被喂鲨鱼的前提下，尽量使自己分到更多的金币。 题意解读&emsp;&emsp;我们先来理解一下题目意思，如题说的五个海盗按照抽签顺序依次提出方案，所以这是有顺序的，然后半数以上的人认可才能被通过，否则人就没了，比如剩下两个海盗了，那么前面那个海盗就肯定挂了，因为最后那位海盗肯定会投票给自己，只要前面那人挂了他就可以独吞金币。为了解题我们可以先假设一个顺序出来，然后再分析分析怎么make more money 解题思考&emsp;&emsp;我们先给五个海盗按照顺序编个号分别是A、B、C、D、E，在这个游戏中咱们的每个海盗都要考虑两点make more money与活着（注意，这个词我划重点了），刚才我们说到，当只剩俩人时，即只剩D、E时，D肯定就挂了，所以机智的D肯定不能让自己陷入只剩俩人的尴尬处境中。 &emsp;&emsp;考虑到这一点是不是有点思路了，我们应该逆向来推这个问题，从两个人的情况开始模拟； 剩余D、E D必然被投死，收获金币0 E收获金币100 剩余C、D、E C需要两票且C知道D不会让自己陷入两人困境肯定会支持自己，再加上自己的票共2票超过了半数，于是大胆的做出了100、0、0的分配 D收获金币0 E收获金币0 剩余B、C、D、E B需要三票且B知道自己死后D、E都收不到一个金币，于是它可以花1个金币把这俩人收买了让他们投自己，再加上自己的票共3票超过了半数，于是做出了98、0、1、1的分配 C收获金币0 D收获金币1 E收获金币1 兄弟全在A、B、C、D、E A需要三票且A知道自己死后C收不到一个金币，所以可以花1个金币收买了C，还差一票可以在D、E中选一个花2个金币收买让其给自己投票，再加上自己的票共3票超过了半数，于是可以做出97、0、1、2、0或者97、0、1、0、2的分配 B收获金币0 C收获金币1 D/E收获金币2 &emsp;&emsp;所以题目的答案是，在第一个位置的人最有利，最多能够分到最多97个金币♂","link":"/2019-07-14-thinking-topic/"},{"title":"算法——猫鼠游戏","text":"&emsp;&emsp;给定一张地图，其中包含猫、老鼠、障碍物三类元素，游戏初始化时猫在地图的左上角，老鼠在地图的右下角，猫每个回合可以选择自己临近格子移动一步，不可超过地图边界，不可移动至有障碍物处，请设计一个算法让猫使用最少的回合抓住老鼠。 游戏设计&emsp;&emsp;首先我们需要设计出整个游戏，并预留出猫的移动逻辑交给用户去实现，这里我基于canvas设计了cat-mouse-game-gen.js来作为游戏构建程序，借助这个脚本使用如下代码即可构建一个猫鼠游戏棋盘： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;canvas id=&quot;gamePlace&quot;&gt;not support canvas&lt;/canvas&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://resources.chenjianhui.site/cat-mouse-game-gen-0.1.9.js&quot;&gt;&lt;/script&gt; &lt;script&gt; gameGen.initGame('gamePlace') &lt;/script&gt; &lt;/html&gt; not support canvas &emsp;&emsp;其中gameGen.initGame(canvasId, catHandler, mouseHandler, options)是游戏的初始化函数，它负责渲染统计数据及运行游戏，函数共接收四个参数 canvasId：canvas画布ID catHandler： 猫的行动决策函数function(chessboard, curIndex, canMovePoints) ，不传此参数代表不行动，函数的返回值即是猫的下一步位置，行动目标是抓住老鼠 chessboard：棋盘局势，是一个一维数组，数组长度为棋盘的总格子数，每个点位的值都是一个对象（exp { flag: 1, depletePower: null }），包括flag（棋子类型）与depletePower（当flag为0时此值不为空，代表行走需要消耗的体力值）两个属性，其中flag的类型码定义如下 0：可移动格子 1：猫 2：老鼠 3：障碍物 curIndex：猫的当前位置 canMovePoints：可以移动的点位，是一个一维数组，代表可移动的位置信息，如果返回值不在此范围内棋子将不会移动 mouseHandler: 老鼠的行动决策函数，介绍同catHandler，行动目标是躲避猫的追击 options: 配置信息 columns：棋盘列的数量，默认为8 rows：棋盘行的数量，默认为16 delay：回合时间延迟毫秒数，默认为800 complexRoad：是否开启复杂道路，默认为false，开启后将会引入不同类型的道路如草地/溪流，不同的道路行走消耗的体力也不同，问题将演变成有优先级的最短路径 &emsp;&emsp;举个例子，以下代码实现了一个随机行动的猫，虽然随机移动的猫抓到老鼠全凭运气，不过这也算一种移动策略了 &lt;canvas id=&quot;randomPlace&quot;&gt;not support canvas&lt;/canvas&gt; &lt;script&gt; const randomHandler = (chessboard, curIndex, canMovePoints) =&gt; { const randomIndex = Math.round(Math.random() * (canMovePoints.length - 1)) return canMovePoints[randomIndex] } gameGen.initGame('randomPlace', randomHandler) &lt;/script&gt; not support canvas 算法设计&emsp;&emsp;至此我们已经有了一个可以根据算法移动的猫了，接下来就是设计猫抓老鼠的算法，我们稍微转化一下这个问题，其实就是根据行动决策函数中的棋盘局势数组去找猫到老鼠之间的最短路径，既然要找最短路径我们免不了要对棋盘进行遍历搜索，在上一篇博客24点游戏中我们讲到搜索算法有DFS与BFS两种策略，我们对比一下这两种策略，DFS算法属于一种盲目搜索，要找到最短路径必然要遍历全局，而BFS扩散式搜索，只要第一次搜索到终点就可以退出，不需要遍历全局，因此在这里我们将使用BFS实现猫的行动策略。 设计思路&emsp;&emsp;我们先假设有一个4*8的棋盘，猫在棋盘的左上角（数组的下标0处），老鼠在棋盘的右下角（数组下标31处），并在3、 10、 13、 18、 28处位置设置了5个障碍物，现在我将基于这个局势去模拟BFS算法的搜索流程。 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 [回合1] 基于位置0搜索可能的走法得到[1, 8]，判断所在点位并非老鼠所在点位，否则基于这两个点位继续搜索 [回合2] 基于位置1搜索 =&gt; [0, 2, 9]，由于0是历史走过点位，因此过滤此项 =&gt; [2, 9]，非目标点，回到点位8进行搜索 [回合2] 基于位置8搜索 =&gt; [0, 9, 16]，过滤 =&gt; [16]，非目标点，回到点位2进行搜索，后面的步骤默认过滤 [回合3] 基于位置2搜索 =&gt; []， 没有可移动点位，回到点位9进行搜索 [回合3] 9 =&gt; [17]，非目标点，回到16 [回合3] 16 =&gt; [24]，非目标点 [回合4 - 8] 24 =&gt; [25]，25 =&gt; [26]，26 =&gt; [27]，27 =&gt; [19]，19 =&gt; [11, 20]，非目标点 [回合9] 11 =&gt; [12]，20 =&gt; [21] [回合10] 12 =&gt; [4]，21 =&gt; [22, 29] [回合11] 4 =&gt; [5]，22 =&gt; [23, 30]，29 =&gt; [] [回合12] 5 =&gt; [6]，23 =&gt; [31]，到达目标点，索引走过的路径为31,23,22,21,20,19,27,26,25,24,16,8,0 &emsp;&emsp;整个流程简单来说就是自左到右自上到下遍历了全部的节点，只不过它是根据层次优先进行遍历的，在层次遍历的过程中如果遇到了目标点位即可返回，因为同一个层次所消耗的回合数是相同的，所以第一次遇到目标点位的路径即是最优解之一。 代码实现&emsp;&emsp;清楚算法流程后，代码的实现相对简单，可以使用递归也可以使用队列，我这边是递归完成最短路径搜索的，具体实现如下： class BFSCat { constructor(options) { // 定义基础行列信息 this.columns = (options &amp;&amp; options.columns) || 16 this.rows = (options &amp;&amp; options.rows) || 8 } /** * 获取最短路径 * @param chessboard 棋盘信息 * @param catIndex 猫的位置 * @returns {Array} 路径信息 无解时返回空数组 */ getShortestWays(chessboard, catIndex) { return this.search(chessboard, [{cur: catIndex, ways: []}]) } /** * 根据当前棋盘局势搜索出一条最短路径 * @param curChessboard 当前棋盘局势 * @param curs 猫的当前位置 * @param history 历史走过的路径 * @returns {Array} 返回最短路径 无解时返回空数组 */ search(curChessboard, curs, history) { if (!history) history = [] let nexts = [] for (let i in curs) { const curObj = curs[i]; const cur = curObj.cur const ways = curObj.ways const effectNeighbors = this.getEffectNeighbors(history, cur, curChessboard) for (let j in effectNeighbors) { const next = effectNeighbors[j] if (curChessboard[next].flag === 2) { // 广度遍历抓到老鼠 直接返回路径 return ways.slice().concat([cur, next]) } } // 缓存历史路径 history = history.concat(effectNeighbors) nexts = nexts.concat(effectNeighbors.map(next =&gt; ({ cur: next, ways: ways.slice().concat([cur]) }))) } if (nexts.length === 0) { // 无路可走 此题无解 return [] } return this.search(curChessboard, nexts, history) } /** * * @param history 历史走过的路径 防止走回头路 * @param cur 当前位置 * @param chessboard 棋盘信息 * @returns {Array} 下一步可能的走法 */ getEffectNeighbors(history, cur, chessboard) { let result = [] const p = this.computeXY(cur) const columns = this.columns const rows = this.rows if (p.x &gt; 0 &amp;&amp; this.checkNextPoint(chessboard[cur - 1])) result.push(cur - 1) if (p.x &lt; columns - 1 &amp;&amp; this.checkNextPoint(chessboard[cur + 1])) result.push(cur + 1) if (p.y &gt; 0 &amp;&amp; this.checkNextPoint(chessboard[cur - columns])) result.push(cur - columns) if (p.y &lt; rows - 1 &amp;&amp; this.checkNextPoint(chessboard[cur + columns])) result.push(cur + columns) return result.filter(next =&gt; !(history &amp;&amp; history.includes(next))) } /** * 根据棋盘的相对位置计算棋子的坐标 * @param index 棋盘相对位置 * @returns {{x: number, y: number}} */ computeXY(index) { const columns = this.columns const x = index % columns const y = Math.floor(index / columns) return {x, y} } /** * 判断下一步点位是否可以移动 */ checkNextPoint(point) { return point.flag !== 3 } } 效果演示&emsp;&emsp;将使用基于BFS算法策略设计的猫加入到猫鼠游戏，效果如下： &lt;canvas id=&quot;BFSPlace&quot;&gt;not support canvas&lt;/canvas&gt; &lt;script&gt; let cacheWays = null let index = 0 const catHandler = (chessboard, curIndex, canMovePoints) =&gt; { if (cacheWays === null) { cacheWays = new BFSCat().getShortestWays(chessboard, curIndex) if (cacheWays.length === 0) { throw new Error('此题无解') } } return cacheWays[index++] } gameGen.initGame('BFSPlace', catHandler , null) &lt;/script&gt; not support canvas 加强版猫鼠游戏&emsp;&emsp;普通版的猫鼠游戏我们使用基于BFS的最短路径搜索算法即可找到最优解了，现在我们将游戏升级，引入不同类型的道路，请设计一个算法让猫使用最少的体力抓住老鼠，其中加强版猫鼠游戏引入的三种道路类型如下： 普通道路 ：消耗一点体力值 草地 ：消耗两点体力值 溪流 ：消耗三点体力值 &emsp;&emsp;同样我们先构建出这个棋盘，只需要将options.complexRoad配置为true即可，未加入行动决策算法的棋盘效果如下： &lt;canvas id=&quot;complexRoadPlace&quot;&gt;not support canvas&lt;/canvas&gt; &lt;script&gt; gameGen.initGame('complexRoadPlace', null, null, { complexRoad: true }) &lt;/script&gt; not support canvas 解题思考&emsp;&emsp;加强版本的游戏要考虑体力消耗最小，因此最短的路径未必消耗的体力就是最少的，这个很容易理解，所以我们不能单考虑最短路径这个方面去解题了，还应该考虑到不同道路的体力消耗。 A星寻路算法&emsp;&emsp;可以直接点击A*算法wiki查看一下算法的背景，我在这里只介绍算法的一些核心概念，在A*算法中有两个核心概念 G值：起始点到行动点的移动量 起始点：猫的初始位置 行动点：猫的下一步决策位置 移动量：在这里我们考虑地形的情况下是可移动格子的体力消耗量 H值：行动点到终点的估算量，这个值仅仅是一个估算值，比如位置1到位置31的估算值我们忽略地形可以取最小格子数，即9 终点：老鼠的位置 估算量：这里是不考虑障碍物的一个估算移动量 &emsp;&emsp;好的核心概念介绍完，我们基于一个棋盘来完成A星算法的决策流程，下面的棋盘和上面的基本一致，区别在于加入了地形因素，每个可行走的格子中用括号括起来的就是特殊地形的体力消耗值，这将会影响到各个点位的G、H值。 0 1(2) 2 3 4 5 6 7 8 9(2) 10 11 12 13 14 15(2) 16 17 18 19 20(3) 21(3) 22 23(3) 24(2) 25 26 27 28 29 30 31 &emsp;&emsp;现在我们基于上述棋盘来简述一下A星算法的决策流程，首先我们要基于当前行动点求出邻近可移动点的G、H值，根据F = G + H公式得出点位的和值F，然后找一个F值最小的点作为当前行动点继续进行判断，直到找到老鼠位置或者无点可选。在这个过程中，我们需要定义两个列表 open列表：记录下所有被考虑的点位列表 close列表：记录下所有不被考虑的点位列表 &emsp;&emsp;现在我将基于这个局势去模拟A星算法的搜索流程，其中🔕代表不被考虑的点位close、代表当前行动点、代表被考虑的点位open、F()括号内部的值代表被考虑点位的和值G + H，现在我们一步一步的模拟如下： [回合1] 基于位置0搜索到可能走法[1, 8]，计算和值为[1(2 + 9), 8(1 + 9)]，open = [1(11), 8(10)]、close = [0(10)]，括号内为和值F 0 1(2)F(11) 2 3 4 5 6 7 8🐱F(10) 9(2) 10 11 12 13 14 15(2) 16 17 18 19 20(3) 21(3) 22 23(3) 24(2) 25 26 27 28 29 30 31 [回合2] 在open列表找到和值最小的点作为当前行动点，找到可能走法计算和值并加入到open列表，同时当前行动点放入close列表，在这里我们将选择点8作为当前行动点，此时 open = [1(11), 9(11), 16(10)、close = [0(10), 8(10)] 0 1(2)🐱F(11) 2 3 4 5 6 7 8 9(2)🐱F(11) 10 11 12 13 14 15(2) 16🐱F(10) 17 18 19 20(3) 21(3) 22 23(3) 24(2) 25 26 27 28 29 30 31 [回合3] 选择16，此时open = [1(11), 9(11), 17(10), 24(11)、close = [0(10), 8(10), 16(10)] 0 1(2)🐱F(11) 2 3 4 5 6 7 8 9(2)🐱F(11) 10 11 12 13 14 15(2) 16 17🐱F(10) 18 19 20(3) 21(3) 22 23(3) 24(2)🐱F(11) 25 26 27 28 29 30 31 [回合4] 选择17 0 1(2)🐱F(11) 2 3 4 5 6 7 8 9(2)🐱F(11) 10 11 12 13 14 15(2) 16 17 18 19 20(3) 21(3) 22 23(3) 24(2)🐱F(11) 25🐱F(10) 26 27 28 29 30 31 [回合5] 选择25 0 1(2)🐱F(11) 2 3 4 5 6 7 8 9(2)🐱F(11) 10 11 12 13 14 15(2) 16 17 18 19 20(3) 21(3) 22 23(3) 24(2)🐱F(11) 25 26🐱F(10) 27 28 29 30 31 [回合6] 选择26 0 1(2)🐱F(11) 2 3 4 5 6 7 8 9(2)🐱F(11) 10 11 12 13 14 15(2) 16 17 18 19 20(3) 21(3) 22 23(3) 24(2)🐱F(11) 25 26🔕🚶 27🐱F(10) 28 29 30 31 [回合7] 选择27，注意，这里由于路障问题绕路了，所以F值变为了12(7 + 5) 0 1(2)🐱F(11) 2 3 4 5 6 7 8 9(2)🐱F(11) 10 11 12 13 14 15(2) 16 17 18 19🐱F(12) 20(3) 21(3) 22 23(3) 24(2)🐱F(11) 25 26🔕 27🔕🚶 28 29 30 31 [回合8] 选择1 0 1(2)🔕🚶 2🐱F(11) 3 4 5 6 7 8 9(2)🐱F(11) 10 11 12 13 14 15(2) 16 17 18 19🐱F(12) 20(3) 21(3) 22 23(3) 24(2)🐱F(11) 25 26🔕 27🔕 28 29 30 31 [回合9 - 12] 选择2、9、24，发现都为死路，加入close列表，最终只能选择19 0 1(2)🔕 2🔕 3 4 5 6 7 8 9(2)🔕 10 11🐱F(14) 12 13 14 15(2) 16 17 18 19🔕🚶 20(3)🐱F(14) 21(3) 22 23(3) 24(2)🔕 25 26🔕 27🔕 28 29 30 31 [回合13] 选择20，当出现F值相同的情况我们就取第一个判断生成的，我的判断是自左向右、自上到下，所以点位20先被判断 0 1(2)🔕 2🔕 3 4 5 6 7 8 9(2)🔕 10 11🐱F(14) 12🐱F(16) 13 14 15(2) 16 17 18 19🔕 20(3)🔕🚶 21(3)🐱F(16) 22 23(3) 24(2)🔕 25 26🔕 27🔕 28 29 30 31 [回合14] 选择11，我们发现以点11为行动点的相邻点12计算出的F值为14比16小，故更新节点 0 1(2)🔕 2🔕 3 4 5 6 7 8 9(2)🔕 10 11🔕🚶 12🐱F(14) 13 14 15(2) 16 17 18 19🔕 20(3)🔕 21(3)🐱F(16) 22 23(3) 24(2)🔕 25 26🔕 27🔕 28 29 30 31 [回合15 - 18] 选择12、4、5、6 0 1(2)🔕 2🔕 3 4🔕 5🔕 6🔕🚶 7🐱F(16) 8 9(2)🔕 10 11🔕 12🔕 13 14🐱F(16) 15(2) 16 17 18 19🔕 20(3)🔕 21(3)🐱F(16) 22 23(3) 24(2)🔕 25 26🔕 27🔕 28 29 30 31 [回合19] 选择7 0 1(2)🔕 2🔕 3 4🔕 5🔕 6🔕 7🔕🚶 8 9(2)🔕 10 11🔕 12🔕 13 14🐱F(16) 15(2)🐱F(17) 16 17 18 19🔕 20(3)🔕 21(3)🐱F(16) 22 23(3) 24(2)🔕 25 26🔕 27🔕 28 29 30 31 [回合20] 选择14 0 1(2)🔕 2🔕 3 4🔕 5🔕 6🔕 7🔕 8 9(2)🔕 10 11🔕 12🔕 13 14🔕🚶 15(2)🐱F(17) 16 17 18 19🔕 20(3)🔕 21(3)🐱F(16) 22🐱F(16) 23(3) 24(2)🔕 25 26🔕 27🔕 28 29 30 31 [回合21] 选择22 0 1(2)🔕 2🔕 3 4🔕 5🔕 6🔕 7🔕 8 9(2)🔕 10 11🔕 12🔕 13 14🔕 15(2)🐱F(17) 16 17 18 19🔕 20(3)🔕 21(3)🐱F(16) 22🔕🚶 23(3)🐱F(18) 24(2)🔕 25 26🔕 27🔕 28 29 30🐱F(16) 31 [回合22] 选择30，发现邻近点中有目标点，且值为16是最短路径之一，遍历完成，具体路径为 0,8,16,17,25,26,27,19,11,12,4,5,6,14,22,30,31，共消耗体力值16点 0 1(2)🔕 2🔕 3 4🔕 5🔕 6🔕 7🔕 8 9(2)🔕 10 11🔕 12🔕 13 14🔕 15(2)🐱F(17) 16 17 18 19🔕 20(3)🔕 21(3)🐱F(16) 22🔕 23(3)🐱F(18) 24(2)🔕 25 26🔕 27🔕 28 29🐱F(18) 30🔕🚶 31🐱F(16) 代码实现-1class AStarCat { constructor(options) { // 定义基础行列信息 this.columns = (options &amp;&amp; options.columns) || 16 this.rows = (options &amp;&amp; options.rows) || 8 } /** * 获取最优解 * @param chessboard 棋盘信息 * @returns {Array} 路径信息 无解时返回空数组 */ getShortestWays(chessboard) { const catIndex = chessboard.findIndex(item =&gt; item.flag === 1) const mouseIndex = chessboard.findIndex(item =&gt; item.flag === 2) return this.search(chessboard, {cur: catIndex, ways: []}, catIndex, mouseIndex) } /** * 搜索路径 * @param curChessboard 棋盘信息 * @param curObj 当前行动点对象 * @param catIndex 猫的初始位置 * @param mouseIndex 老鼠的初始位置 * @param open 被考虑的点位 * @param close 不被考虑的点位 * @returns {Array} 返回最优路径 无解时返回空数组 */ search(curChessboard, curObj, catIndex, mouseIndex, open, close) { if (!open) open = [] if (!close) close = [] const cur = curObj.cur close.push(cur) open.splice(open.findIndex(o =&gt; o.cur === cur), 1) const effectNeighbors = this.getEffectNeighbors(close, cur, curChessboard) const nextOpen = effectNeighbors.map(next =&gt; { const ways = curObj.ways.concat([next]) return { cur: next, f: this.computeF(mouseIndex, next, ways, curChessboard), ways: ways } }) // 如果open与nextOpen有交集，取更小值 nextOpen.forEach(n =&gt; { let sameIndex = open.findIndex(o =&gt; o.cur === n.cur) if (sameIndex &gt; -1) { if (n.f &lt; open[sameIndex].f) { open.splice(sameIndex, 1, n) } } else { open.push(n) } }) open = open.concat() const success = open.find(o =&gt; o.cur === mouseIndex) if (success) { return success.ways } if (open.length &gt; 0) { return this.search(curChessboard, open.sort((a, b) =&gt; (a.f - b.f))[0], catIndex, mouseIndex, open.slice(), close.slice()) } return [] } /** * * @param close 不被考虑的节点 * @param cur 当前位置 * @param chessboard 棋盘信息 * @returns {Array} 下一步可能的走法 */ getEffectNeighbors(close, cur, chessboard) { let result = [] const p = this.computeXY(cur) const columns = this.columns const rows = this.rows if (p.x &gt; 0 &amp;&amp; this.checkNextPoint(chessboard[cur - 1])) result.push(cur - 1) if (p.x &lt; columns - 1 &amp;&amp; this.checkNextPoint(chessboard[cur + 1])) result.push(cur + 1) if (p.y &gt; 0 &amp;&amp; this.checkNextPoint(chessboard[cur - columns])) result.push(cur - columns) if (p.y &lt; rows - 1 &amp;&amp; this.checkNextPoint(chessboard[cur + columns])) result.push(cur + columns) return result.filter(next =&gt; !(close &amp;&amp; close.includes(next))) } /** * 计算GH的和值 * @param mouseIndex 老鼠的位置 * @param curIndex 当前行动点 * @param ways 当前行动点的历史路径 * @param chessboard 棋盘信息 */ computeF(mouseIndex, curIndex, ways, chessboard) { const mouseP = this.computeXY(mouseIndex) const curP = this.computeXY(curIndex) const g = ways.reduce((a, b) =&gt; (chessboard[a].depletePower + chessboard[b].depletePower), 0) const h = Math.abs(curP.x - mouseP.x) + Math.abs(curP.y - mouseP.y) return g + h } /** * 根据棋盘的相对位置计算棋子的坐标 * @param index 棋盘相对位置 * @returns {{x: number, y: number}} */ computeXY(index) { const columns = this.columns const x = index % columns const y = Math.floor(index / columns) return {x, y} } /** * 判断下一步点位是否可以移动 */ checkNextPoint(point) { return point.flag !== 3 } } 效果演示-1&lt;canvas id=&quot;AStarPlace&quot;&gt;not support canvas&lt;/canvas&gt; &lt;script&gt; let cacheWays = null let index = 0 const catHandler = (chessboard, curIndex, canMovePoints) =&gt; { if (cacheWays === null) { cacheWays = new AStarCat().getShortestWays(chessboard) if (cacheWays.length === 0) { throw new Error('此题无解') } } return cacheWays[index++] } gameGen.initGame('AStarPlace', catHandler , null, { complexRoad: true }) &lt;/script&gt; not support canvas 升级玩法&emsp;&emsp;在这个游戏中，我们不仅可以设计猫的行动策略函数，还可以设计老鼠的行动策略函数来躲避猫的追击，有兴趣的同学可以想想如果躲避算法又应该如何实现。 参考资料 A星寻路算法-(入门级) - Colin丶- CSDN博客 gameGen.initGame('staticPlace') gameGen.initGame('randomPlace', (chessboard, curIndex, canMovePoints) => canMovePoints[Math.round(Math.random() * (canMovePoints.length - 1))]) let cacheWaysOfBSF = null let indexOfBSF = 0 const catHandlerOfBFS = (chessboard, curIndex, canMovePoints) => { if (cacheWaysOfBSF === null) { cacheWaysOfBSF = new BFSCat().getShortestWays(chessboard, curIndex) if (cacheWaysOfBSF.length === 0) { throw new Error('此题无解') } } return cacheWaysOfBSF[indexOfBSF++] } gameGen.initGame('BFSPlace', catHandlerOfBFS , null) gameGen.initGame('complexRoadPlace', null, null, { complexRoad: true }) let cacheWaysOfAStar = null let indexOfAstar = 0 const catHandlerOfAstar = (chessboard, curIndex, canMovePoints) => { if (cacheWaysOfAStar === null) { cacheWaysOfAStar = new AStarCat().getShortestWays(chessboard) if (cacheWaysOfAStar.length === 0) { throw new Error('此题无解') } } return cacheWaysOfAStar[indexOfAstar++] } gameGen.initGame('AStarPlace', catHandlerOfAstar , null, { complexRoad: true })","link":"/2019-06-20-algorithm-topic/"},{"title":"算法——24点游戏","text":"&emsp;&emsp;给定四个1-10的正整数，可以进行+ - * / 四种运算，每个数字只能用一次，任意组合构造表达式使结果为24，要找出所有可能的组合？ 解题思考&emsp;&emsp;初拿到题目最先想到的就是穷举法了，我们先假设四个数字为A、B、C、D，然后穷举所有的可能性，简单算一下可以得到一共有4! * 4^3 = 1536种可能性，如下图所示： DFS解法&emsp;&emsp;DFS是Depth-First search 深度优先搜索的简称，与其对应的还有BFS(Breadth-First-Search 广度优先搜索)，在这里我们使用递归的方式深度优先遍历搜索树找到所有可能性，然后根据得出的算术表达式（如1+2+3*4）计算并判断筛选出计算结果为24的组合，代码如下： import java.util.*; import java.util.regex.Pattern; import java.util.stream.Collectors; /** * @author JianhuiChen * @description 24点游戏 * @date 2019/6/18 */ public class Count24 { public static void main(String[] args) { List&lt;String&gt; results = permutation(Arrays.asList(1, 2, 3, 4), Arrays.asList(Operator.PLUS, Operator.MINUS, Operator.MULTIPLY, Operator.DIVIDE)); results.stream() .filter(express -&gt; expectCalc(express, 24)) .forEach(System.out::println); } private static List&lt;String&gt; permutation(List&lt;Integer&gt; numbers, List&lt;Operator&gt; operators) { return permutation(numbers, operators, null); } /** * 深度优先搜索策略得出所有的组合可能性 * * @param numbers 参与选择的数字 * @param operators 参与运算的运算符 * @param expressRecord 算术表达式记录值 * @return 可能性组合 */ private static List&lt;String&gt; permutation(List&lt;Integer&gt; numbers, List&lt;Operator&gt; operators, String expressRecord) { if (expressRecord == null) { expressRecord = &quot;&quot;; } List&lt;String&gt; resultList = new ArrayList&lt;&gt;(); for (int num : numbers) { if (numbers.size() == 1) { // 只剩一个数字未选时退出循环 resultList.add(expressRecord + num); break; } for (Operator oper : operators) { // 过滤掉已选项 List&lt;Integer&gt; optional = numbers.stream() .filter(n -&gt; n != num) .collect(Collectors.toList()); resultList.addAll(permutation(optional, operators, expressRecord + num + oper)); } } return resultList; } /** * 进行预期运算 * * @param aritExpression 算术表达式 * @param targetVal 目标值 * @return 是否符合预期 */ private static boolean expectCalc(String aritExpression, int targetVal) { return calculation(aritExpression) == targetVal; } /** * 根据算术表达式求值 * * @param aritExpression 算术表达式 exp: 4*2/1*3 * @return 计算结果 */ private static int calculation(String aritExpression) { // 将表达式根据运算符切割 StringTokenizer tokenizer = new StringTokenizer(aritExpression, &quot;+-*/&quot;, true); Stack&lt;Double&gt; numStack = new Stack&lt;&gt;(); // 存放数字 Stack&lt;Operator&gt; operStack = new Stack&lt;&gt;(); // 存放操作符 String currentEle; // 当前元素 while (tokenizer.hasMoreTokens()) { currentEle = tokenizer.nextToken().trim(); // 去掉前后的空格 if (!&quot;&quot;.equals(currentEle)) { // 只处理非空字符 if (Pattern.matches(&quot;^\\\\d+(\\\\.\\\\d+)?$&quot;, currentEle)) { // 为数字时则加入到数字栈中 numStack.push(Double.valueOf(currentEle)); } else { Operator currentOper = Operator.getOperatorBySymbol(currentEle);//获取当前运算操作符 if (currentOper == null) { throw new RuntimeException(&quot;存在无效的操作符&quot; + currentEle); } while (!operStack.empty() &amp;&amp; operStack.peek().priority() &gt;= currentOper.priority()) { compute(numStack, operStack); } // 计算完后把当前操作符加入到操作栈中 operStack.push(currentOper); } } } // 经过上面代码的遍历后最后的应该是nums里面剩两个数或三个数，operators里面剩一个或两个运算操作符 while (!operStack.empty()) { compute(numStack, operStack); } return numStack.pop().intValue(); } /** * 取numStack的最顶上两个数字 * operStack的最顶上一个运算符进行运算 * 然后把运算结果再放到numStack的最顶端 * * @param numStack 数字栈 * @param operStack 操作栈 */ private static void compute(Stack&lt;Double&gt; numStack, Stack&lt;Operator&gt; operStack) { Double num2 = numStack.pop(); // 弹出数字栈最顶上的数字作为运算的第二个数字 Double num1 = numStack.pop(); // 弹出数字栈最顶上的数字作为运算的第一个数字 Double computeResult = operStack.pop().compute(num1, num2); // 弹出操作栈最顶上的运算符进行计算 numStack.push(computeResult); // 把计算结果重新放到队列的末端 } /** * 支持的运算符 */ private enum Operator { PLUS(&quot;+&quot;) { @Override public int priority() { return 1; } @Override public double compute(double a, double b) { return a + b; } }, MINUS(&quot;-&quot;) { @Override public int priority() { return 1; } @Override public double compute(double a, double b) { return a - b; } }, MULTIPLY(&quot;*&quot;) { @Override public int priority() { return 2; } @Override public double compute(double a, double b) { return a * b; } }, DIVIDE(&quot;/&quot;) { @Override public int priority() { return 2; } @Override public double compute(double a, double b) { return a / b; } }; Operator(String symbol) { this.symbol = symbol; } /** * 运算符 */ private String symbol; /** * @return 运算优先级 */ public abstract int priority(); /** * @param a 第一个运算数 * @param b 第二个运算数 * @return 两个数对应的运算结果 */ public abstract double compute(double a, double b); /** * 根据运算符查找运算操作类 * * @param symbol 运算符 * @return 运算操作类 */ public static Operator getOperatorBySymbol(String symbol) { for (Operator operator : Operator.values()) { if (symbol.equals(operator.toString())) { return operator; } } return null; } @Override public String toString() { return symbol; } } } &emsp;&emsp;输入2、4、6、8能得到以下部分结果 2*6+4+8 2*6+8+4 2*6*8/4 2*6/4*8 2*8*6/4 2*8/4*6 2/4*6*8 2/4*8*6 2/8+4*6 2/8+6*4 4+2*6+8 4+6*2+8 4+8+2*6 4+8+6*2 4*6+2/8 4*8-2-6 ...优化思路&emsp;&emsp;上述算法做了很多的重复计算，众所周知，加法和乘法是满足交换律的，所以如1*2*3*4这类组合任意排列所得的计算结果都是相同的，针对这部分我们可以如爬楼梯问题的备忘录算法缓存计算结果，防止重复计算。 题目拓展，添加优先级&emsp;&emsp;我们简单的将上述的24点游戏扩展一下，除了数字和运算符我们再加上括号的选择，这个时候有多少种情况？代码该如何变更？其实简单想想加上括号即让任意组合如ABCD又演变出了五种加括号的方式((AB)C)D、(A(BC))D、(AB)(CD)、A(((BC)D)、A(B(CD))，然后根据括号运算搜索出正确答案即可，有兴趣的同学可以修改上述代码完成该题。","link":"/2019-06-17-algorithm-topic/"},{"title":"算法——爬楼梯问题","text":"&emsp;&emsp;有一座高度是1000级台阶的天梯，从下往上走，每跨一步只能向上1级或者2级台阶。要找出一共有多少种走法？ 解题思考&emsp;&emsp;如题1000级台阶着实有点多了，我们先来思考6级阶梯的情况，共13种  1+1+1+1+1+1  1+1+1+1+2  1+1+1+2+1  1+1+2+1+1  1+2+1+1+1  2+1+1+1+1  1+1+2+2  1+2+1+2  1+2+2+1  2+1+1+2  2+1+2+1  2+2+1+1  2+2+2 &emsp;&emsp;在仅有6级阶梯的情况下穷举已经有一些费力了，如果是1000级那几乎不可能穷举了，我们要思考找出其中的微妙之处。&emsp;&emsp;现在我们假设只差最后一步就能达到第6级阶梯了，那么会出现几种情况？无非就是从第5级花费一步或者从第4级花费两步跳到第6级阶梯，我们现在假设0-4级阶梯有X种走法，0-5级阶梯有Y种走法，那么0-6级阶梯的走法有多少种？ 差一步 ==6级== 差两步 ==5级== ?种走法 ==4级== Y种走法 ==3级== X种走法 ==2级== ==1级== &emsp;&emsp;我们来分析一下，要走到第6级阶梯最后一步必然从4或5级阶梯开始的，而4或5级阶梯我们知道它的走法为X与Y，那么显然0-6级阶梯的走法即为X+Y，这个时候我们可以发现，每一级阶梯的走法数目其实都是由它的前两级阶梯来决定的，即可用此函数表示 fun(N) = func(N - 1) + func(N - 2) &emsp;&emsp;且我们知道第1级的阶梯有一步走法，第二级的阶梯有两步走法，所以函数完整的表示为 func(1) = 1func(2) = 2fun(N) = func(N - 1) + func(N - 2) &emsp;&emsp;这种解题思路即是动态规划思想，将大事化小，小事化了，转换为简单的问题，其中最后一步必然从4或5级阶梯开始这个称之为最优子结构，上述的方程称之为状态转移方程，func(1|2)称之为边界。 编码实现递归实现&emsp;&emsp;上述的方程随眼一看即知道，这是一个递归方程，现在我们使用递归编程来实现此题的解法。 public int getStairsWays(int n) { if (n &lt;= 0) { return 0; } if (n == 1 || n == 2) { return n; } return getStairsWays(n - 1) + getStairsWays(n - 2); } &emsp;&emsp;其实稍微计算一下这套实现的时间复杂度你就会发现非常恐怖，它的计算量相当于一个二叉树，时间复杂度达到了O(2^N)，空间复杂度为O(1)。这道题目的优化空间是很大的，我们首先思考一下它的计算过程，我们可以发现很多都是重复计算的 func(5) = func(4) + func(3) func(4) = func(3) + func(2) func(3) = func(2) + func(1) &emsp;&emsp;func(3)被重复计算了很多次，为了降低计算次数，我们可以将已经计算过的缓存起来，不去重新计算它。 备忘录算法&emsp;&emsp;备忘录算法是递归实现了一种改良版，使用了一块内存区域来存储已经计算过的阶梯数，防止重复计算，在这里使用的是HashMap对象，其实更优的选择应该是一个长度为阶梯高度的int数组。 public int getStairsWays(int n) { return getStairsWays(n, null); } public int getStairsWays(int n, Map&lt;Integer, Integer&gt; cache) { if (n &lt;= 0) { return 0; } if (n == 1 || n == 2) { return n; } if (cache == null) { // 初始化一个缓存对象 容量为log(n)的向上取整 cache = new HashMap&lt;&gt;((int) Math.ceil(Math.log(n) / Math.log(2))); } if (cache.containsKey(n)) { return cache.get(n); } int value = getStairsWays(n - 1, cache) + getStairsWays(n - 2, cache); cache.put(n, value); return value; } &emsp;&emsp;我们大概看一下这个算法的时间与空间复杂度，备忘录缓存了各级背包的计算结果因此它真正计算的只有n次，时间复杂度为O(N)，由于需要内存去缓存计算结果，所以它的空间复杂度也为O(N)&emsp;&emsp;我们可以再分析一下，还有没有更优的解法呢？重新观察我们的计算过程 func(6) = func(5) + func(4) func(5) = func(4) + func(3) func(4) = func(3) + func(2) func(3) = func(2) + func(1) &emsp;&emsp;func(6)只依赖于func(5)与func(4)，所以当func(5)与func(4)的结果值出来以后，func(3)这个结果就再没必要缓存了，我们把思维逆转一下，从func(3)开始计算到func(6)。 动态规划算法&emsp;&emsp;这里我们考虑使用自底向上的解法，只需要用两个变量来存储它的两个依赖值，分别是差两步的走法数目(pre)以及差一步的走法数目(next)，最终的走法数目为这两个依赖值的和。 public int getStairsWays(int n) { if (n &lt;= 0) { return 0; } if (n == 1 || n == 2) { return n; } int pre = 1; int next = 2; for (int i = 3; i &lt; n; i++) { int temp = next; next = pre + next; pre = temp; } return pre + next; } &emsp;&emsp;分析一下这个算法的时间与空间复杂度，循环n-2次计算，所以时间复杂度是O(N)，内存上只开辟了两个临时变量没有额外的内存空间使用，所以空间复杂度为O(1)，这就是真正的动态规划算法。&emsp;&emsp;有兴趣的同学可以测试一下以上三个算法在1000个阶梯的量级下运行时间，反正我使用递归运行了一下1000次阶梯，等了十分钟也没结果最终放弃了… 有没有更优解&emsp;&emsp;答案是有的，且时间复杂度为O(logN)，有兴趣的可以搜索数论中的矩阵快速幂，可根据状态转移方程快速计算出结果，与动态规划思想结合使用。&emsp;&emsp;还有就是我们来观察上面讲到的状态转移方程，不难看出这表示的是一个斐波那契数列，而斐波那契数列是有通项公式的，在如这种特定问题下可以直接代入通项公式求解。 题目扩展，-背包问题&emsp;&emsp;给定一组多个（n）物品，每种物品都有自己的重量（Wi）和价值（Vi），每种物品至多选择一个，在限定可承受总重量（C）的背包内，要想背包内物品的总价值最高，应该选择那几件物品？ 简化题目&emsp;&emsp;我们先假设有5组物品，其中它的价值与重量分别为[4,2,1,3,1]、[4,3,2,1,2]，背包可承受总重量为6，求应该选那几件物品使得背包中的物品价值最大？ 动态规划思路四步解题问题是否可拆分？&emsp;&emsp;如爬楼梯问题可以拆分成剩余一步与剩余两步的走法，此问题该如何拆分？ 我们先针对最后一个物品(价值为1，重量为2)做假设(1) 装载物品进入背包，问题演变成，有4组物品，背包承重量为4，应该选那几件物品使得背包中的物品价值最大？(2) 物品不被装载，问题演变成，有4组物品，背包承重量为6，应该选那几件物品使得背包中的物品价值最大？(3) 接下来我们还可以对子情况(1)、(2)分别做假设，因此该问题是可拆分的。 最优子结构是什么？&emsp;&emsp;如爬楼梯的问题的最优子结构是剩余一步与剩余两步的走法相加，此问题的最优结构是什么？ &emsp;&emsp;针对我们刚刚的假设(1)、(2)，要想使得背包物品价值最大，最优的结构显而易见是(1)、(2)情况中背包价值更大的那个方案。 状态转移方程是什么？ 问题拆分及找出最优子结构后，状态转移方程就很好推导了，存在两种情况(1) 背包容量大于等于下一个物品的重量：物品存在选择与不选两种情况(2) 背包容量小于下一个物品重量：物品不可被选择，情况只有一种 &emsp;&emsp;可得背包问题的状态转移方程为 func(n, c) = max(func(n - 1, c - W[n - 1]) + V[n - 1], func(n - 1, c)) (n &gt; 1, c &gt;= W[n - 1])func(n, c) = func(n - 1, c) (n &gt; 1, c &lt; W[n - 1])其中n =&gt; 剩余物品数量c =&gt; 背包剩余容量W =&gt; 物品重量数组V =&gt; 物品价值数组 边界是什么？&emsp;&emsp;问题不断的向子问题拆分后一定会有一个头，如爬楼梯是将一阶和二阶楼梯作为边界，针对背包问题，它的边界是什么？ 不难想到，当只剩最后一个物品，此时没有多余的物品能够选择了，就只能选择此物品，而选择此问题有两种情况(1) 背包容量大于等于物品重量：此时返回物品价值(2) 背包容量小于物品重量：此时返回0 &emsp;&emsp;可得背包问题的边界为 func(1, c) = V[0] (n = 1, c &gt;= W[0])func(1, c) = 0 (n = 1, c &lt; W[0]) 编码实现-1简单递归/** * 获取最大价值 * * @param n 物品数量 * @param c 背包剩余承重量 * @param w 物品重量 * @param v 物品价值 * @return 背包装配物品的最大价值 */ int getMaxValues(int n, int c, int[] w, int[] v) { if (n == 1) { // 边界 if (c &gt;= w[0]) { return v[0]; } else { return 0; } } if (c &gt;= w[n - 1]) { // 状态转移公式 return Math.max(getMaxValues(n - 1, c - w[n - 1], w, v) + v[n - 1], getMaxValues(n - 1, c, w, v)); } else { return getMaxValues(n - 1, c, w, v); } } 备忘录算法-1int getMaxValues(int n, int c, int[] w, int[] v) { return getMaxValues(n, c, w, v, null); } int getMaxValues(int n, int c, int[] w, int[] v, Map&lt;String, Integer&gt; cache) { if (n == 1) { // 边界 if (c &gt;= w[0]) { return v[0]; } else { return 0; } } if (cache == null) { cache = new HashMap&lt;&gt;((int) Math.ceil(Math.log(n) / Math.log(2))); } if (cache.containsKey(generatorCacheKey(n, c))) { return cache.get(generatorCacheKey(n, c)); } int value; if (c &gt;= w[n - 1]) { // 状态转移公式 value = Math.max(getMaxValues(n - 1, c - w[n - 1], w, v, cache) + v[n - 1], getMaxValues(n - 1, c, w, v, cache)); } else { value = getMaxValues(n - 1, c, w, v, cache); } cache.put(generatorCacheKey(n, c), value); return value; } String generatorCacheKey(int n, int c) { return String.format(&quot;%s_%s&quot;, n, c); } 动态规划算法-1&emsp;&emsp;跟爬楼梯问题一样，我们自底向上来思考这个问题，我们不妨基于简化的问题画一个表格来分析这个情况，表格第一列表示5个物品的情况，括号内代表价值与重量，表格的第一行表示给予的背包容量，其余的空白格子代表背的最大价值数。 &emsp;&emsp;简化的问题：有5组物品，其中它的价值与重量分别为[4,2,1,3,1]、[4,3,2,1,2]，背包可承受总重量为6。 剩余1容量 剩余2容量 剩余3容量 剩余4容量 剩余5容量 剩余6容量 物品1 (4,4) 物品2 (2,3) 物品3 (1,2) 物品4 (3,1) 物品5 (1,2) &emsp;&emsp;第一行非常容易填写，只有一个物品的情况下，背包最大价值要么为0要么为4，各自中箭头前面描述的是选择了那几个物品。 剩余1容量 剩余2容量 剩余3容量 剩余4容量 剩余5容量 剩余6容量 物品1 (4,4) 0 0 0 1 =&gt; 4 1 =&gt; 4 1 =&gt; 4 物品2 (2,3) 物品3 (1,2) 物品4 (3,1) 物品5 (1,2) &emsp;&emsp;我们将其余的格子全部填写完成，接下来的这几段很重要，理解它就理解了动态规划算法的核心。 物品(v,w)/c 剩余1容量 剩余2容量 剩余3容量 剩余4容量 剩余5容量 剩余6容量 物品1 (4,4) 0 0 0 1 =&gt; 4 1 =&gt; 4 1 =&gt; 4 物品2 (2,3) 0 0 2 =&gt; 2 1 =&gt; 4 1 =&gt; 4 1 =&gt; 4 物品3 (1,2) 0 3 =&gt; 1 2 =&gt; 2 1 =&gt; 4 1 =&gt; 4 1,3 =&gt; 5 物品4 (3,1) 4 =&gt; 3 4 =&gt; 3 3,4 =&gt; 4 1,3 =&gt; 5 1,4 =&gt; 7⭐ 1,4 =&gt; 7 物品5 (1,2) 4 =&gt; 3 4 =&gt; 3 3,4 =&gt; 4 1,3 =&gt; 5 1,4 =&gt; 7 1,4 =&gt; 7 我们来找一下规律 先回顾一下核心的状态转移方程 func(n, c) = max(func(n - 1, c - W[n - 1]) + V[n - 1], func(n - 1, c)) 我们先看/这个图标组合，做一个方程代入 n = 3 , c = 6 , V[2] = 1 , W[2] = 2注意，这里V[2]、W[2]对应的是物品3，因为数组从0开始编号func(3, 6) = max(func(2, 4) + 1 , func(2, 6)) 再看⭐/这个图标组合，做一个方程代入 n = 4 , c = 5 , V[3] = 3 , W[3] = 1func(4, 5) = max(func(3, 4) + 3 , func(3, 5)) &emsp;&emsp;规律已经很明显了，每个格子的数据都只依赖于它的前一行数据，和爬楼梯中我们最后只存储了前两步数据的思路一样，在这里我们只需要存储前一行的数据即可推导出下一行的数据，编码的思路和我们填充表格的思路一致，代码如下： int getMaxValues(int n, int c, int[] w, int[] v) { int[] pre = new int[c + 1]; // 前一行 int[] current = new int[c + 1]; // 当前行 for (int i = 1; i &lt;= c; i++) { // 先填充第一行 if (i &lt; w[0]) { pre[i] = 0; } else { pre[i] = v[0]; } } for (int i = 1; i &lt; n; i++) { for (int j = 1; j &lt;= c; j++) { // 填充第二行到最后 if (j &lt; w[i]) { // 容量不够 current[j] = pre[j]; } else { current[j] = Math.max(pre[j - w[i]] + v[i], pre[j]); } } // 此处不可直接使用等号 会出现引用混乱的情况 pre = Arrays.copyOf(current, current.length); } return current[c]; } 题目扩展，采金矿&emsp;&emsp;有一个国家发现了n座金矿，每座金矿的黄金储量（Vi）不同，需要参与挖掘的工人数（Li）也不同。参与挖矿工人的总数是C人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ &emsp;&emsp;此题是背包问题的变种，解题思路是一样的，有兴趣的同学可以自己思考一下。","link":"/2019-06-13-algorithm-topic/"},{"title":"算法——老鼠毒药问题","text":"&emsp;&emsp;有16瓶水，其中一瓶有毒，小白鼠喝一滴有毒的水一小时后会死，要在一小时找出来哪瓶水有毒最少需要几只小白鼠 ？ 构造题目/** * @author JianhuiChen * @description 老鼠毒药问题 * @date 2019/6/12 */ public class MousePoisonQuestion { public static void main(String[] args) { normalSolution(); } /** * 普通解法 16瓶水用16只老鼠来找 哪只死了代表哪瓶水有毒 */ private static void normalSolution() { final int bottleCount = 16; List&lt;Mouse&gt; mouseList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bottleCount; i++) { mouseList.add(new Mouse(i, Collections.singleton(i))); } findPoisonWater(bottleCount, mouseList, mouses -&gt; mouses.stream() .filter(Mouse::isDie) .findFirst() .get() .getId()); } /** * 寻找有毒的水 * * @param bottleCount 水的瓶数 * @param mouses 老鼠列表 * @param judge 根据老鼠喝完水的状态判断出毒药的编号 */ private static void findPoisonWater(int bottleCount, List&lt;Mouse&gt; mouses, Function&lt;List&lt;Mouse&gt;, Integer&gt; judge) { List&lt;Water&gt; waters = initWaters(bottleCount); mouses.forEach(mouse -&gt; mouse.setDie(waters)); // 一小时后 int resultPoisonId = judge.apply(mouses); int poisonId = waters.indexOf(waters.stream().filter(Water::isPoison).findFirst().get()); Water water = waters.get(poisonId); assert (water.isPoison()) : &quot;判断有误,第&quot; + poisonId + &quot;瓶水不是毒药,正确答案是第&quot; + resultPoisonId + &quot;瓶&quot;; System.out.println(&quot;恭喜你找出了包含毒药的水,共使用了&quot; + mouses.size() + &quot;只老鼠&quot;); } /** * 初始化Len瓶水 * * @param len 水瓶数 * @return 带有一瓶毒药的水列表 */ private static List&lt;Water&gt; initWaters(int len) { Boolean[] poisons = new Boolean[len]; poisons[new Random().nextInt(len)] = true; return Arrays.stream(poisons) .map(poison -&gt; new Water(poison != null)) .collect(Collectors.toList()); } /** * 老鼠对象 */ static class Mouse { /** * 老鼠喝过的水ID */ private Integer[] drinkWaterIds; /** * 老鼠ID */ private int id; /** * 老鼠是否死亡 */ private boolean die; Mouse(int id, Collection&lt;Integer&gt; drinkWaterIds) { this.id = id; this.drinkWaterIds = drinkWaterIds.toArray(new Integer[]{}); } void setDie(List&lt;Water&gt; waters) { this.die = Arrays.stream(drinkWaterIds) .anyMatch(id -&gt; waters.get(id).isPoison()); } boolean isDie() { return die; } int getId() { return id; } } /** * 水对象 */ static class Water { /** * 是否有毒 */ private boolean poison; Water(boolean poison) { this.poison = poison; } boolean isPoison() { return poison; } } } 解题思考&emsp;&emsp; 显然，使用了十六只老鼠来找这瓶毒药肯定不是最优解，我们来想，16瓶水中有一瓶毒药一共有16种可能性，而老鼠有生存和死亡两种状态，假设我们使用0和1表示老鼠的生存与死亡，那么四只老鼠就能排列组合出16种可能性，我们来利用二进制排列出这16种情况。 老鼠1 老鼠2 老鼠3 老鼠4 水 0 0 0 1  瓶子1 0 0 1  0 瓶子2 0 0 1  1  瓶子3 0 1  0 0 瓶子4 0 1  0 1  瓶子5 0 1  1  0 瓶子6 0 1  1  1  瓶子7 1  0 0 0 瓶子8 1  0 0 1  瓶子9 1  0 1  0 瓶子10 1  0 1  1  瓶子11 1  1  0 0 瓶子12 1  1  0 1  瓶子13 1  1  1  0 瓶子14 1  1  1  1  瓶子15 排列下来即是 老鼠1喝 8，9，10，11，12，13，14，15 老鼠2喝 4，5，6，7，12，13，14，15 老鼠3喝 2，3，6，7，10，11，14，15 老鼠4喝 1，3，5，7，9，11，13，15 这样排列后，老鼠的生存与死亡状态都能得到一串二进制码，这串二进制码可以转换成有毒的瓶子信息，如 0010：表示老鼠3死亡，其余老鼠存活，代表瓶子2是毒药 0000：表示没有老鼠死亡，代表瓶子16是毒药 编码实现/** * 使用二进制的思路解法 */ private static void binarySolution() { final int bottleCount = 16; List&lt;Mouse&gt; mouseList = new ArrayList&lt;&gt;(); mouseList.add(new Mouse(1, Arrays.asList(8, 9, 10, 11, 12, 13, 14, 15))); mouseList.add(new Mouse(2, Arrays.asList(4, 5, 6, 7, 12, 13, 14, 15))); mouseList.add(new Mouse(3, Arrays.asList(2, 3, 6, 7, 10, 11, 14, 15))); mouseList.add(new Mouse(4, Arrays.asList(1, 3, 5, 7, 9, 11, 13, 15))); findPoisonWater(bottleCount, mouseList, mouses -&gt; { int num = -1; for (Mouse m : mouses) { num += Math.pow(2, m.isDie() ? (m.getId() - 1) : 0); } return num &lt; 0 ? (bottleCount - 1) : num; }); } &emsp;&emsp;运行后程序将打印“恭喜你找出了包含毒药的水,共使用了4只老鼠”，代码运行成功了没错，但是通用性不足，只能够适用于16只老鼠的解法，能否编写一个根据瓶子数量作为参数的通用解法函数？只要理解解题思路，这个代码并不难，在此就不做演示了。 &emsp;&emsp;有兴趣的朋友可以在下方留言给出通用解法 题目拓展&emsp;&emsp;有16瓶水，其中只有一瓶水有毒，小白鼠喝一滴之后一小时会死。请问最少用多少只小白鼠，可以在1小时内找出至少14瓶无毒的水。 &emsp;&emsp;找14瓶无毒的水是可以转化为和上面那道一样的解题思路，我们将16瓶水分为8组两两一瓶，我们只需要找到一组水中包含毒药即可得到14瓶无毒的水，一组水只可能有两种状态，有毒或者无毒，所以我们可以将8组水看作8瓶水，至此题目就变成了“8瓶水用最少几只老鼠找那瓶有毒的水”，答案是3只。","link":"/2019-06-12-algorithm-topic/"},{"title":"使用Docker搭建隔离开发环境","text":"使用Docker搭建隔离开发环境 前言&emsp;&emsp; 最近接触到了Docker相关的知识，了解了它的相关特性，并基于它搭建了一些如mysql/redis/mq作为一个后端开发所必须的的环境，为什么使用Docker来搭建，听我娓娓道来。 &emsp;&emsp; 梦回到刚学后端的时候，你需要搭建个mysql环境，然后你去搜了下windows mysql 环境搭建，得到了一种叫绿色版安装，一种叫傻瓜式（安装包）式安装，一顿操作之后我们的电脑终于多了一个mysql的服务，然后使用Navicat成功连接上了，开始沾沾自喜。 &emsp;&emsp;一个月后，由于某种原因（可能你删了mysql包的哪个文件）你需要把mysql重装一下，于是乎你又去搜了下windows mysql 卸载，你惊喜的得到了这么一个结果 &emsp;&emsp;WTF？彻底卸载可还行，于是你花了比安装更多的力气去卸载了一个mysql。 &emsp;&emsp;工作一年之后，你回想起你的这波操作，不禁笑了起来，你看着现在的vmware+centOS虚拟机中挂着的mysql+redis环境不禁沾沾自喜，虚拟机中的开发环境与本机完全隔离，哪天我不要环境了直接把虚拟机卸了就行，真是一个很完美的配置呢~ &emsp;&emsp;但是，你似乎忘记了，你花费了多大的力气踩了多少的坑才折腾好你这套环境，想到这你不禁为自己留下心疼的眼泪。 &emsp;&emsp;这套环境支撑你跑了很久，在此之间你还学会了很多linux的常规指令，成为了一个运维小能手，有一天你在逛社区的时候看到一篇文章叫做使用 Docker 快速搭建开发环境，能有多“快”，我得去瞅瞅，跟着它敲了一遍代码，mysql，它，起来了。 &emsp;&emsp;我告诉自己，我得去看看这东西，它是个什么妖魔鬼怪。 Docker介绍&emsp;&emsp;Docker于2013年发布， 属于 Linux 容器的一种封装，提供简单易用的容器使用接口，可以轻易的使用/制作一个镜像（带有环境的容器）。具体详细的介绍网上有太多了，这里就不赘述了。 环境搭建Windows-Docker环境搭建&emsp;&emsp;环境搭建的文章也很多，我这里主要说一下可能会踩到的坑，docker针对windows的用户主要有两个安装包可以下载，我们可以在阿里云平台看到关于安装的Docker的一些建议，具体区别可以参考这篇博客dockerToolbox和docker for windows的区别，本文主要讲一下Docker for Windows的安装流程。 Docker Toolbox：Docker工具集安装器 Docker for Windows：Windows平台的Docker安装 进入https://www.docker.com/products/docker-desktop 下载Docker for Windows安装包； 执行Docker for Windows安装程序，一路next，Docker运行成功后会有通知且右下角有logo图标存在； 没了，Docker这就算安装好了，使用PowerShell或者cmd执行命令试试 Docker安装完成后，由于它需要Hyper-V的支持，这会与VMware的虚拟机启动产生冲突报错如下，具体原因请参考Docker 和 vmware 共存工作 熟悉一下基本流程&emsp;&emsp;在这个阶段我们使用Docker拉取一个集成了SSH服务的centOS7系统镜像，将它运行起来并使用Xshell远程连接做一些基本的linux操作 # docker pull 拉取镜像指令 # jdeathe/centos-ssh代表镜像名称 centos-7代表镜像标签（版本）不填取最新latest # 具体镜像信息查看 https://hub.docker.com/ docker pull jdeathe/centos-ssh:centos-7 # docker images 查看已经拉取的镜像列表 docker images # docker run 将镜像构建成容器 # -d 分离运行 不会在命令行打印容器运行日志 # --name 指定容器名称 # -p 2020:22 将本机的2020端口映射到容器的22端口 # --env 设置容器支持的环境配置 # jdeathe/centos-ssh:centos-7 镜像名称 docker run -d --name centos-ssh -p 2020:22 --env SSH_PASSWORD_AUTHENTICATION=true --env SSH_USER=admin --env SSH_USER_PASSWORD=123456 jdeathe/centos-ssh:centos-7 # docker inspect 查看指定容器的详细信息 centos-ssh是刚刚指定的容器名称 docker inspect centos-ssh # docker ps 查看容器信息 运行成功则会显示在列表中 docker ps # 使用XShell进入容器 locahost:2020 admin/123456 &emsp;&emsp;成功连接上容器并执行了一些基础操作 &emsp;&emsp;除去不必要的打印信息指令，我们只需要使用两行代码即可创建一个centOS系统镜像容器 可视化界面&emsp;&emsp;指令操作虽然能让你更加熟练且装逼，但它总是繁琐的，Docker官方及周边提供了很多基于Docker指令的傻瓜式UI程序，在这里我主要介绍两款 Kitematic-GUI程序&emsp;&emsp;Kitematic是由Docker官方提供的一款桌面应用，提供了Windows平台下的绿色版压缩包，使用起来非常简单。 前往Kitematic的github releases仓库下载Kitematic-XXX-Windows.zip； 解压直接运行 Kitematic.exe，界面如下 点击一个容器可进入详情页面 点击Settings进入配置页面 Portainer-Web程序&emsp;&emsp;Portainer是一个轻量级的管理界面，可以让您轻松地管理不同的Docker环境，功能比Kitematic强大许多。 &emsp;&emsp;Portainer是基于网页来操作的，本质上是一个B/S架构的程序，它有单独的镜像发布在Docker中，所以它的使用也非常便捷，我们只需要拉取镜像运行即可。 # 拉取最新的portainer镜像 docker pull portainer/portainer # --restart=always 代表容器总是随着Docker启动而启动 # -v 配置持久化路径 docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name portainer portainer/portainer # 检查服务运行状态 docker ps # 正常情况下服务已经运行在 http://localhost:9000 进入 http://localhost:9000/#/init/admin ， 进行管理员配置； 初始化Docker端点配置http://localhost:9000/#/init/endpoint ， 需要配合在Docker配置开启Web Api服务； 进入Portainer主页，查看相关配置 开发集成环境搭建&emsp;&emsp;在有了前面环境的铺垫之后，现在可以很轻易就搭建好我们所需要的开发环境，具体操作无非是 找到所需的镜像及版本，拉取镜像 根据镜像描述做好配置并启动 测试环境是否可用 mysql&emsp;&emsp;任意找一个GUI程序搜索到所需的镜像，拉取运行即可 &emsp;&emsp;关于mysql连接密码可在环境变量中配置重启 &emsp;&emsp;使用Navicat测试连接是否可用，这里主要要看镜像与宿主机器的端口映射表，使用 localhost:3306 root/123456 即可连接上mysql，环境搭建成功 redis&emsp;&emsp;使用Kitematic搜索redis相关镜像，点击创建，使用RedisDesktopManager进行测试，默认是没有密码验证的模式，如果需要更改可以进入容器内部修改，这部分操作我会在后续的博客整理 rabbitmq&emsp;&emsp;其他的环境操作都是类似的，当然如果没有搜索你想要的镜像（比如你想要一个mysql+redis的镜像），可以自己构建发布，在此之前你可能需要注册一个Docker账号 其他配置Docker镜像加速&emsp;&emsp;注册一个阿里云账号，进入控制台-&gt;容器镜像服务-&gt;镜像中心-&gt;镜像加速器，获取到加速器的地址，复制到Docker的Settings/Daemon中，重启Docker即可。 参考资料 Windows 10 安装Docker for Windows - 晓晨Master - 博客园 使用 Docker 快速搭建开发环境 dockerToolbox和docker for windows的区别- Null的博客- CSDN博客 Docker 和 vmware 共存工作 - rodert - CSDN博客 Docker各种可视化界面的比较","link":"/2019-04-19-docker-env/"},{"title":"我的博客可以自己部署啦","text":"博客你已经长大了，该学会自己部署了 我的自动化运维平台已经成功上线啦~ 博客可以自己照顾自己啦~ 本篇博客用于测试自动化运维平台是否正常运行 在我写完这篇博客执行以下脚本后 git add . git commit -m&quot;自动部署测试&quot; git push origin master 这时候对话开始了 github：jenkins兄弟，快起来，该干活了 Jenkins看看来的任务，blogs，ok，i know jenkins：包在我身上 # 拉取代码 git clone https://github.com/calebman/blog.git # 打印版本 node -v npm -v # 安装hexo-cli脚手架 npm install -g hexo-cli hexo -v # 安装依赖 npm i # 打包博客 hexo clean hexo g # 将打包文件移动到服务器的指定目录 nginx配置目录 cp -rf public/* /home/app/application/blogs/ # 部署到 github.io hexo d jenkins：发封邮件给主人告诉他我干完了 盯 看看手机，好的看来博客已经上线了 访问http://blog.chenjianhui.site试试 有了，jenkins辛苦辣，下次给你换个更好的服务器环境 测试成功Ending~","link":"/2019-03-07-blog-with-jenkins/"},{"title":"前后端分离模式下的DevOps","text":"Jenkins+Git+Maven+Nodejs实现前后端分离项目的自动化运维 背景概述理解Devops&emsp;&emsp; 维基百科对Devops的定义是：一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 &emsp;&emsp;自动化运维以及持续集成部署是Devops的核心思想，当你发现自己每天花费了大量的时间在等待程序打包/上传至服务器等过程中时，你就应该思考，是否需要将这些重复性的行为交给机器去做，来解放自己花费在这部分的时间。 我为何要引入Devops背景简介&emsp;&emsp;楼主是一个常年在二三线城市小公司漂泊的苦逼程序员，小公司的特性就是一人当三人使，一个人兼做开发测试加运维，公司采用敏捷开发模式，现有平台4套，大部分都是前后端分离的系统，由于功能调整的比较快导致部署演示的频次非常高，最多会出现一天部署10次左右，再加上ssh文件上传与webpack的打包程序的运行时间较长，最快的本地打包+ssh上传+启动远程运行脚本的流程走下来也得5min左右，所以光部署这一块花费的人力成本已经不可忽略了。 应用架构简介&emsp;&emsp;楼主公司的web应用主要采用SpringBoot+Vuejs前后端分离开发模式，打包后的应用由Nginx来动静内容分发，应用架构的详情可见我的另一篇博客前后端分离开发模式的实践总结，源代码获取点击这里，本文也将围绕着这个结构的工程来做自动化部署。 冲突与问题 等待程序打包时间过长（特别是webpack的打包），大部分时间在等待，这件事在进行中也不好做别的事情 重复性劳动过多，每次打包都是运行打包脚本，上传打包后的文件夹，运行远程启动脚本 容易出错，假设现有的环境是两套（演示与生产），那么远端运行脚本需要根据环境的不同来传递不同的环境变量，人为错误极易发生 理想环境 程序员提交代码至dev分支，此时触发演示环境的打包部署程序 技术老大提交代码至master分支，此时触发生产环境的打包部署程序 打包成功/失败/中断通知到钉钉工作群 Devops实践Windows10环境搭建 java：JDK开发环境搭建及环境变量配置 tomcat：Windows安装和配置Tomcat git：Git安装教程 jenkins 点此下载jenkins的war包 将jenkins.war复制到tomcat服务器的webapps目录下 配置jenkins的工作目录，在我的电脑-属性-高级系统设置-环境变量-添加系统变量JENKINS_HOME，内容是一个空的文件夹，作为jenkins的工作目录。如果不想设置系统环境变量也可以修改加载有jenkins.war的tomcat目录下的conf\\context.xm文件，如下设置JENKINS_HOME 访问jenkins的主页http://localhost:8080/jenkins &lt;!-- tomcat context.xml 环境变量设置 --&gt; &lt;Context&gt; &lt;!-- 设置jenkins的工作目录 --&gt; &lt;Environment name=&quot;JENKINS_HOME&quot; value=&quot;C:/jenkins/&quot; type=&quot;java.lang.String&quot;/&gt; &lt;/Context&gt; CentOS7-3环境搭建&emsp;&emsp;在CentOS7下搭建jenkins和Windows环境差不多，jenkins是一个依赖于web容易的war包，所以只要有java与tomcat环境即可 git环境# 判断git是否已存在 打印内容则代表存在 git --version # 不存在则安装 出现complete说明安装成功 yum install -y git jdk环境 jdk1.8下载：点此下载 解压配置 mkdir /usr/java # 使用Xftp将下载的jdk放到此目录 cd /usr/java # 解压jdk tar -zxvf jdk-8u201-linux-x64.tar.gz # 修改配置文件 vim /etc/profile # 文件末尾添加java的环境变量 JAVA_HOME=/usr/java/jdk1.8.0_201 JRE_HOME=/usr/java/jdk1.8.0_201/jre PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export JAVA_HOME JRE_HOME PATH CLASSPATH # 使得配置生效 source /etc/profile # 测试配置 java -version tomcat环境 tomcat8下载：点此下载 解压配置 # 使用Xftp将下载的tomcat放到此目录 mkdir /usr/tomcat cd /usr/tomcat # 解压tomcat tar -zxvf apache-tomcat-8.5.38.tar.gz # 测试运行 cd apache-tomcat-8.5.38 sh bin/startup.sh # 检测服务是否成功启动 打印了进程即说明启动成功 netstat -nlp|grep 8080 # 稍微清理一下tomcat 删除没有用的项目 rm -rf /usr/tomcat/apache-tomcat-8.5.38/webapps/* # 配置自动启动 /etc/rc.d/init.d 为启动运行脚本的目录 cd /etc/rc.d/init.d # 创建自启动脚本 touch tomcat # 写入脚本信息 vim tomcat # 脚本信息如下 以下注释信息也需要复制进脚本文件 # 如果缺少了chkconfig:234 20 80这个注释会报错无法识别为自启脚本 #!/bin/sh #chkconfig:234 20 80 #description:tomcat JAVA_HOME=/usr/java/jdk1.8.0_201 export JAVA_HOME PATH=$JAVA_HOME/bin:$PATH export PATH tomcat_path=/usr/tomcat/apache-tomcat-8.5.38/bin case &quot;$1&quot; in start) echo &quot;start tomcat service..&quot; sh ${tomcat_path}/startup.sh ;; *) exit 1 ;; esac # 赋予权限 chmod 755 tomcat # 注册tomcat服务自启 chkconfig --add tomcat # 测试服务是否能够自启 先停止运行中的tomcat sh /usr/tomcat/apache-tomcat-8.5.38/bin/shutdown.sh service tomcat start netstat -nlp|grep 8080 # 查看所有注册自启的服务 chkconfig jenkins环境 jenkins下载：点此下载 配置 mkdir /usr/jenkins # 使用Xftp将下载的tomcat放到此目录 cd /usr/jenkins # 复制jenkins.war至tomcat/webapps目录 cp jenkins.war /usr/tomcat/apache-tomcat-8.5.38/webapps # jenkins.war会自动解包启动 进入tomcat/webapps目录查看 jenkins.war已经解包成了文件夹 cd /usr/tomcat/apache-tomcat-8.5.38/webapps ls # 修改tomcat环境配置将jenkins的工作目录切换至/home/app/jenkins vi /usr/tomcat/apache-tomcat-8.5.38/conf/context.xml # Context标签下添加以下内容 &lt;Environment name=&quot;JENKINS_HOME&quot; value=&quot;/home/app/jenkins&quot; type=&quot;java.lang.String&quot;/&gt; # 重启tomcat cd /usr/tomcat/apache-tomcat-8.5.38 sh bin/shutdown.sh sh bin/startup.sh # 检查工作目录切换是否成功 有文件即成功 cd /home/app/jenkins # 清空原先的工作空间 jenkins默认工作空间为 /root/.jenkins rm -rf /root/.jenkins 配置JenkinsJenkins的初始化 第一次进入jenkins时会要求使用初始密码解锁，按照提示操作就行了 之后会提示你安装插件，在这里我们采用默认安装必要的插件即可，其他的插件我们可以在系统内部再去安装 耐心等待插件安装完毕 初始化完成，配置管理员用户 配置jenkins实例地址，举个例子解释实例配置的地址用处 假设你做了项目打包成功或者失败的通知，jenkins构建的默认通知信息里会带有一个进入系统的链接地址，方便用户直接从邮件/钉钉等地方进入系统查看构建详情，这个地址即是此处配置的实例地址 所有配置完成后，成功进入系统 Jenkins的环境配置环境需求分析 拉取远端master分支代码：Git插件 运行前端打包脚本：Nodejs环境 运行后端打包脚本：Java环境+Maven插件 推送装有构建代码的文件夹：SSH文件传输插件 运行远程启动脚本：SSH脚本运行插件 配置插件&emsp;&emsp;对应jenkins/系统管理/插件管理目录，根据上述的打包流程得出插件需求，在baidu/google搜索得到jenkins上对应的插件名称，选择并安装它们。 插件的选择 Publish Over SSH：基于SSH协议的文件上传插件 Nodejs：nodejs运行环境 Dingding：钉钉推送通知 Maven Integration：Maven插件 插件的安装 进入jenkins-系统管理-插件管理 选择available（可选插件）标签 搜索出以上选择的插件，勾选之后点击直接安装 配置全局工具&emsp;&emsp;对应jenkins/系统管理/全局工具配置目录，主要是配置打包所需的环境，如Java/Git/Maven等等，如果系统自带环境可以填写系统环境，如果没有可以采用jenkins自动安装的方式。 JDK配置 tips：如果找不到java的安装目录可以使用 which java 查看 Git配置 tips：如果找不到git的安装目录可以使用 which git 查看 Maven配置 NodeJS配置 配置文件管理&emsp;&emsp;对应jenkins/系统管理/Managed files目录，主要是管理自定义的配置文件，如Maven的settings.xml，Npm的npmrc.config文件等等，我们在这主要配置一下Maven和Npm的仓库镜像，使其切换到国内的阿里云的Maven镜像和淘宝的Npm镜像。 Maven settings.xml &emsp;&emsp;新增Maven settings.xml配置文件，在mirrors标签下添加以下配置 &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; Npm config file &emsp;&emsp;新增Npm config file配置文件，修改registry的配置 registry=https://registry.npm.taobao.org 配置全局凭据&emsp;&emsp;对应jenkins/凭据/系统/全局凭据目录，主要是用于添加如gitlab/ssh等受限访问应用的信任凭据。 其他配置 Publish over SSH插件 &emsp;&emsp;该插件的配置在jenkins/系统管理/系统设置目录，主要的配置如下： &emsp;&emsp;高级配置下还可以配置SSH端口，重置默认设置等等，这里不做过多讲解 Dingding通知使用 &emsp;&emsp;钉钉通知的配置在任务的配置项中，配置起来较为简单（比微信通知简单太多）只需要两步操作。 （1）获取钉钉通知自定义机器人webhook的access_token，点此进入钉钉开放平台获取配置帮助 （2）在任务中配置通知 &emsp;&emsp;通知效果如图，点击即可进入jenkins管理平台查看详情 Jenkins的任务配置&emsp;&emsp;至此基于一个前后端分离项目的自动打包配置已经基本完成，现在我们使用jenkins构建一个任务来测试配置是否成功，本次构建任务是基于我的一个开源模板项目server-front-separate来进行。 新建任务&emsp;&emsp;进入jenkins根目录点击新建任务 &emsp;&emsp;任务新建成功 任务基础配置&emsp;&emsp;本次的基础配置我们需要达到任务能够自动化打包的效果，为达到此效果我们至少需要配置以下几项内容： 源码管理 构建环境 后端构建步骤 前端构建步骤 源码管理 构建环境 后端构建步骤 前端构建步骤 linux环境下采用Shell脚本构建，换行分割指令 cd front/ node -v npm -v npm i npm run build Windows环境下采用批处理脚本构建，使用&amp;与&amp;&amp;来连接指令，&amp;代表下一条指令必定执行，&amp;&amp;代表当上一条指令出现错误下一条指令不执行 cd front/ &amp; node -v &amp; npm -v &amp; npm i &amp;&amp; npm run build 构建运行&emsp;&emsp;基础配置完成后，我们进入项目主页进行一次构建测试 &emsp;&emsp;构建成功后进入任务的工作空间，可以查看到项目已经打包成功，项目的目录结构描述详见我的另一篇博客前后端分离开发模式的实践总结 Jenkins任务自动化&emsp;&emsp;至此项目已经能够通过jenkins平台来进行打包操作了，但是这还远远没达到自动化的概念，我们的目标是通过git代码提交操作来触发构建并且自动部署到生产/演示服务器上，所以接下来进行自动化的配置工作 自动构建&emsp;&emsp;自动构建是指通过Git服务器的Webhooks来触发Jenkins的打包构建流程，在这里我们将实现以下流程： 更新代码至github项目的master分支 jenkins开始构建代码 &emsp;&emsp;jenkins默认对github的webhook有支持使得这个流程的配置非常简单，jenkins的webhook触发地址为${JENKINS_URL}/github-webhook/，其中JENKINS_URL为jenkins服务在公网的根目录地址，可以在jenkins/系统管理/系统设置处修改此默认地址 &emsp;&emsp;得到Webhook地址后我们只需要在github的项目Settings选项卡上添加此地址即可，github默认触发Webhook的逻辑是push代码时即触发 &emsp;&emsp;当然，别忘记了在jenkins的任务中勾选Github hook触发构建 自动部署&emsp;&emsp;自动部署是指在代码构建完成后将生成的发布代码推送到远程服务器中并启动它们，流程如下： 代码构建成功后上传打包目录 运行远程脚本重启服务 &emsp;&emsp;上文我们讲到Publish Over SSH这个插件能够远程推送代码并运行脚本，自动部署的功能即依赖此插件，配置如下： # 定义脚本执行地址 export COMMAND_PATH=/home/app/application/server-front-separate/bin # 将所有脚本文件转换为UNIX格式 sed -i 's/\\r//' $COMMAND_PATH/*.sh # 停止服务 sh $COMMAND_PATH/stop.sh test # 启动服务 sh $COMMAND_PATH/start.sh test 构建通知&emsp;&emsp;在这里我们使用钉钉来做通知功能，钉钉通知的配置在上文已经介绍过了，通知的的类型有四种，我们需要哪种类型的通知直接勾选即可，四种通知类型正好对应jenkins任务构建的三种状态： 成功：构建步骤与构建后的操作全部成功，对应构建成功时通知 失败：构建步骤失败，对应构建失败时通知 不稳定：构建步骤成功但构建后的操作存在失败的情况，对应构建中断时通知 常见问题中文乱码&emsp;&emsp;在jenkins/系统管理/系统设置中添加全局属性： 参考资料 Jenkins——应用篇——插件使用——Publish over SSH Jenkins 集成钉钉机器人 Jenkins之解决乱码问题 Jenkins与Github集成 webhook配置","link":"/2019-03-01-devops-practice/"},{"title":"前后端分离开发模式的实践总结","text":"SpringBoot+Vuejs+Nginx从开发至部署构建一个成熟的前后端分离应用 前言&emsp;&emsp; 实践前后端分离的开发模式已经有两年左右的时间了，对于前后端分离开发模式的概念在这里不做过多解释，本文主要是总结开发模式并构建一个较为成熟的前后端分离应用 技术选型&emsp;&emsp; 关于技术选型方面线下国内比较流行的主要是SpringBoot+Vuejs这个技术栈，所以本文将基于这个技术栈来讲解，涉及到的技术主要有 环境 Java Maven Nodejs Nginx 前端 vue-cli 后端 SpringBoot 环境准备&emsp;&emsp; 这里简要引用Windows下的环境搭建，关于Linux(Centos7)的环境搭建会再部署架构中讲到 Java : JDK开发环境搭建及环境变量配置 Maven :Maven开发环境搭建 Nodejs :NodeJS、NPM安装配置与测试步骤(windows版本) Nginx :windows下nginx的安装及使用 构建前后端分离工程目录规划&emsp;&emsp;整体目录主要分为三块，如下所示 &emsp;&emsp;打包后的目录主要分为三块，如下所示 后端工程&emsp;&emsp;后端工程主要基于SpringBoot脚手架搭建，SpringBoot基础的集成环境搭建可以参考我的另一篇博客SpringBoot集成环境搭建 &emsp;&emsp;首先创建一个只有Web功能的SpringBoot项目，修改其maven打包的配置实现以下两个功能 将打包的jar文件移动至dist目录下 将多环境配置文件从jar内部移动至外部的dist/config目录下 &emsp;&emsp;此项修改主要依赖于以下两个maven插件 maven-resources-plugin maven-antrun-plugin &emsp;&emsp;详细的插件配置如下，在server/pom.xml的plugins标签下添加如下代码 &lt;!--复制配置文件--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-resources&lt;/id&gt; &lt;phase&gt;validate&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-resources&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;${project.basedir}/../dist/config&lt;/outputDirectory&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;!--移动并重命名jar包--&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;run&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;target&gt; &lt;move file=&quot;${project.basedir}/target/${project.artifactId}-${project.version}.${project.packaging}&quot; tofile=&quot;${project.basedir}/../dist/${project.artifactId}-${project.version}.${project.packaging}&quot;/&gt; &lt;/target&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &emsp;&emsp;进入到server/pom.xml同级目录，执行mvn clean package指令，打包成功会在dist目录下生成编译后的jar文件，dist/config目录下生成项目的配置文件 前端工程&emsp;&emsp;前端工程主要基于vue-cli脚手架创建，vue项目的环境搭建可以参照vue-用Vue-cli从零开始搭建一个Vue项目&emsp;&emsp;现在创建一个基础的vue项目，修改config/index.js配置以实现打包的静态资源生成至dist/html目录 &emsp;&emsp;进入到front/package.json同级目录，执行npm run build指令，打包成功会在dist/html目录生成静态文件 集成测试来个接口&emsp;&emsp;编写一个获取用户信息的接口 @SpringBootApplication @Controller public class ServerApplication { public static void main(String[] args) { SpringApplication.run(ServerApplication.class, args); } /** * 获取当前登录用户的个人信息 * * @return 当前登录用户的个人信息 */ @RequestMapping(&quot;/user/me&quot;) @ResponseBody public Map&lt;String, Object&gt; me() { Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(&quot;username&quot;, &quot;admin&quot;); result.put(&quot;roles&quot;, Arrays.asList(&quot;admin&quot;, &quot;normal&quot;, &quot;none&quot;)); result.put(&quot;depts&quot;, Arrays.asList(&quot;办公室&quot;, &quot;组织部&quot;)); result.put(&quot;menus&quot;, Arrays.asList(&quot;工作台&quot;, &quot;系统管理&quot;)); return result; } } 配置代理&emsp;&emsp;配置以下前端工程的代理转发，用于解决开发环境接口调试的跨域问题 写个页面&emsp;&emsp;写个前端页面测试后端接口，进入front/package.json同级目录执行npm i axios -s，修改HelloWord.vue组件为如下代码 &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1 v-if=&quot;loading&quot;&gt;{{ '正在加载用户信息' }}&lt;/h1&gt; &lt;h1 v-else-if=&quot;errMsg&quot;&gt;{{ errMsg }}&lt;/h1&gt; &lt;div v-else&gt; &lt;p&gt;username: {{userInfo.username}}&lt;/p&gt; &lt;p&gt;roles: {{userInfo.roles}}&lt;/p&gt; &lt;p&gt;depts: {{userInfo.depts}}&lt;/p&gt; &lt;p&gt;menus: {{userInfo.menus}}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from 'axios' export default { name: 'HelloWorld', data () { return { loading: false, userInfo: { username: '', roles: [], depts: [], menus: [] }, errMsg: null } }, created () { this.loading = true axios.get('/api/user/me').then(response =&gt; { this.userInfo = response.data }).catch(err =&gt; { console.error(err) this.errMsg = err }).finally(() =&gt; { this.loading = false }) } } &lt;/script&gt; &lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt; &lt;style scoped&gt; h1, h2 { font-weight: normal; } &lt;/style&gt; 进入测试链接http://localost:8081 单点部署nginx配置&emsp;&emsp;分离部署主要依赖于nginx来完成，利用nginx来分发前后端的内容，nginx的配置如下 #user root;# linux下必须有此配置 不然会导致403权限不足 worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; ' '$status $body_bytes_sent &quot;$http_referer&quot; ' '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;'; access_log logs/access.log main; error_log logs/error.log error; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; set $application_path C:/workspace/java/server-front-separate;# 这里的父级路径需要根据项目路径设置 location /api { proxy_pass http://localhost:8080/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location / { alias $application_path/dist/html/; try_files $uri $uri/ /index.html last;# 解决页面刷新404问题 index index.html index.htm; } } } 打包前后端应用 前端应用: 进入front/package.json同级目录，执行npm run build指令 后端应用: 进入server/pom.xml同级目录，执行mvn clean package指令 编写快速启动脚本（支持多环境） linux下启动脚本start.sh #!/bin/sh # 常量定义 export BIN_PATH=$(cd `dirname $0`;pwd) echo BIN_PATH:[$BIN_PATH] cd $BIN_PATH cd .. export CONTEXT_PATH=`pwd` echo CONTEXT_PATH:[$CONTEXT_PATH] export LOG_PATH=/data/logs/sso echo LOG_PATH:[$LOG_PATH] # 需要指定启动的模式是test，还是prod，默认是test，如果不指定的话 ACTION_MODE=$1 if [ &quot;$ACTION_MODE&quot; = &quot;&quot; ] then ACTION_MODE=test fi echo STARTING APPLICATION ACTION_MODE:[$ACTION_MODE] # 判断log文件夹是否存在 不存在则创建 if [ ! -d $LOG_PATH ]; then mkdir $LOG_PATH fi # 删除历史的server.log文件 rm -f $LOG_PATH/server.log # 后台启动应用 并输出控制台日志 nohup java -jar server-0.0.1-SNAPSHOT.jar --spring.profiles.active=$ACTION_MODE &gt;&gt; $LOG_PATH/server.log 2&gt;&amp;1 &amp; # 显示输出前二十行的日志 head -n 20 $LOG_PATH/server.log windows下启动脚本start.bat @echo off :: 设置jar名称 set JAR_NAME=server-0.0.1-SNAPSHOT :: 常量定义 set BIN_PATH=%~dp0 echo BIN_PATH:[%BIN_PATH%] cd %BIN_PATH% cd .. set CONTEXT_PATH=%cd% echo CONTEXT_PATH:[%CONTEXT_PATH%] echo JAR_NAME:[%JAR_NAME%] :: 需要指定启动的模式是test，还是prod，默认是test，如果不指定的话 set /p ACTION_MODE_INPUT=请输入启动环境，不输入采用默认环境[test]: if not &quot;%ACTION_MODE_INPUT%&quot; equ &quot;&quot; (set ACTION_MODE=%ACTION_MODE_INPUT%) else (set ACTION_MODE=test) echo STARTING APPLICATION ACTION_MODE:%ACTION_MODE% set PROCESS_NAME=JAVA_APP_%JAR_NAME%_%ACTION_MODE% title %PROCESS_NAME% echo PROCESS_NAME:[%PROCESS_NAME%] :: 后台启动应用 并输出控制台日志 java -jar %JAR_NAME%.jar --spring.profiles.active=%ACTION_MODE% linux下关闭脚本stop.sh #!/bin/sh # 需要指定停止的模式是test，还是prod，默认是test，如果不指定的话默认取test ACTION_MODE=$1 if [ &quot;$ACTION_MODE&quot; = &quot;&quot; ] then ACTION_MODE=test fi echo STOPPING APPLICATION ACTION_MODE:[$ACTION_MODE] pid=`ps -ef | grep server-0.0.1-SNAPSHOT.jar | grep $ACTION_MODE | grep -v grep | awk '{print $2}'` # 判断进程是否再运行 在运行则终止 if [ -n &quot;$pid&quot; ] then kill -9 $pid echo application stop success else echo application already stop fi windows下关闭脚本stop.bat @echo off :: 设置jar名称 set JAR_NAME=server-0.0.1-SNAPSHOT :: 需要指定终止的模式是test，还是prod，默认是test，如果不指定的话 set /p ACTION_MODE_INPUT=请输入关闭应用的运行环境，不输入采用默认环境[test]: if not &quot;%ACTION_MODE_INPUT%&quot; equ &quot;&quot; (set ACTION_MODE=%ACTION_MODE_INPUT%) else (set ACTION_MODE=test) echo STARTING APPLICATION ACTION_MODE:%ACTION_MODE% echo JAR_NAME:[%JAR_NAME%] set PROCESS_NAME=JAVA_APP_%JAR_NAME%_%ACTION_MODE% echo PROCESS_NAME:[%PROCESS_NAME%] :: 杀死对应进程 tasklist /nh /fi &quot;WINDOWTITLE eq %PROCESS_NAME%&quot;|find /i &quot;cmd.exe&quot; &gt;nul if ERRORLEVEL 1 (echo Application already stop) else (taskkill /fi &quot;WINDOWTITLE eq %PROCESS_NAME%&quot; &gt;nul &amp; echo Application stop success) echo This window will close in 10 seconds ping 127.1 -n 11 &gt;nul 启动nginx以及后端服务 windwos 运行nginx.exe 运行dist/bin/start.bat linux nginx -s start dist/bin/start.sh prod 源码获取https://github.com/calebman/server-front-separate","link":"/2019-02-23-server-front-separate/"},{"title":"Hello Hexo","text":"从掘金到Hexo，从未停止 从掘金切换到Hexo，多读多看多积累，崭新的开始 随手记一下Markdown的相关语法 希望以后能够养成随手记的习惯 毕竟 好记性 不如 烂笔头 标题# 内容 （一级标题） ## 内容 （二级标题） ### 内容 （三级标题） #### 内容 （四级标题） ##### 内容 （五级标题） ###### 内容 （六级标题）效果如下 内容-（一级标题）内容-（二级标题）内容-（三级标题）内容-（四级标题）内容-（五级标题）内容-（六级标题）列表+ 奈文摩尔 + 上古巨神 * 恐怖利刃 * 混沌骑士 - 炼金术士 - 痛苦女王 1. 代达罗斯之殇 2. 阿托斯之棍 3. 梅肯斯姆 * Steam * Dota2 * 绝地求生 * 中国式家长 效果如下 奈文摩尔 上古巨神 恐怖利刃 混沌骑士 炼金术士 痛苦女王 代达罗斯之殇 阿托斯之棍 梅肯斯姆 Steam Dota2 绝地求生 中国式家长 字体**加粗的文字** *倾斜的文字*` ***斜体加粗的文字*** ~~加删除线的文字~~效果如下 加粗的文字倾斜的文字`斜体加粗的文字加删除线的文字 引用&gt;引用内容 &gt;&gt;效果如下 &gt;&gt;&gt;&gt;&gt;&gt;可叠加的引用效果如下 引用内容 效果如下 可叠加的引用 链接[github](https://github.com/calebman) [掘金](https://juejin.im/user/59bc7c00f265da0644289a4b)效果如下 github掘金 分割线--- ---- *** *****效果如下 图片![图片介绍](https://chenjianhui.site/images/avatar.png)效果如下 表格英雄|属性|大招 --|:--:|--: 奈文摩尔|敏捷|魂之挽歌 受折磨的灵魂|智力|煤气罐 混沌骑士|力量|混沌镜像效果如下 英雄 属性 大招 奈文摩尔 敏捷 魂之挽歌 受折磨的灵魂 智力 煤气罐 混沌骑士 力量 混沌镜像 代码块(```) public static void main(String args[]) { System.out.println(&quot;Hello World&quot;); } (```)效果如下 public static void main(String args[]) { System.out.println(&quot;Hello World&quot;); } 任务列表 feature one feature two feature three feature four feature five feature six","link":"/2019-02-21-hello-hexo/"},{"title":"使用Netty构建Http容器","text":"使用Netty构建一个SpringBoot风格的Web框架 要实现怎样的效果 一个SpringBoot框架搭建起来的项目发布接口服务是这样的 SpringBoot搭建教程点击这里 @Controller @RequestMapping(&quot;/v1/product&quot;) public class DocController { @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.GET) @ResponseBody public WebResult search(@PathVariable(&quot;id&quot;) Integer id) { logger.debug(&quot;获取指定产品接收产品id=&gt;%d&quot;, id); if (id == null || &quot;&quot;.equals(id)) { logger.debug(&quot;产品id不能为空&quot;); return WebResult.error(ERRORDetail.RC_0101001); } return WebResult.success(products.get(id)); } } 我希望我使用Netty构建的Web服务器也能使用这样便捷的注解方式去发布我的接口服务 该怎么做 使用Netty自带的编解码、聚合器构建一个带有Http编解码功能的服务器这一点其实非常简单，Netty提供了对应的Http协议的编解码以及聚合器，我们只需要在管道初始化的时候加载它们。 public class HttpPipelineInitializer extends ChannelInitializer&lt;Channel&gt; { //编解码处理器名称 public final static String CODEC = &quot;codec&quot;; //HTTP消息聚合处理器名称 public final static String AGGEGATOR = &quot;aggegator&quot;; //HTTP消息压缩处理器名称 public final static String COMPRESSOR = &quot;compressor&quot;; @Override protected void initChannel(Channel channel) throws Exception { ChannelPipeline pipeline = channel.pipeline(); pipeline.addLast(CODEC, new HttpServerCodec()); pipeline.addLast(AGGEGATOR, new HttpObjectAggregator(512 * 1024)); pipeline.addLast(COMPRESSOR,new HttpContentCompressor()); pipeline.addLast(new AllocHandler()); } } 实现RequestMapping注解，用于标识处理器或者控制器对应匹配的接口地址。 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) public @interface RequestMapping { String[] value() default {}; } 提供启动入口，程序启动时创建Spring容器，并基于Spring初始化必要组件 提供程序入口类 public class CettyBootstrap { private static final Logger logger = LoggerFactory.getLogger(CettyBootstrap.class); private static final String DEFAULT_SPRING_XMLPATH = &quot;classpath:applicantContext.xml&quot;; private static final String DEFAULT_HTTP_SERVER_BEAN_NAME = &quot;defaultHttpServer&quot;; public static void create() { create(DEFAULT_SPRING_XMLPATH); } public static void create(String springXmlpath) { if (StringUtils.isEmpty(springXmlpath)) { springXmlpath = DEFAULT_SPRING_XMLPATH; } logger.debug(&quot;spring框架配置文件地址为{}&quot;, springXmlpath); try { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(springXmlpath.split(&quot;[,\\\\s]+&quot;)); context.start(); logger.debug(&quot;spring框架启动成功&quot;); try { context.getBean(DEFAULT_HTTP_SERVER_BEAN_NAME, DefaultHttpServer.class); } catch (NoSuchBeanDefinitionException ex) { logger.warn(&quot;未配置HttpServer，采用默认配置启动&quot;); context.getAutowireCapableBeanFactory().createBean(DefaultHttpServer.class); } } catch (BeansException e) { e.printStackTrace(); } } } 定义默认实现的HttpServer组件，随Spring容器启动时加载基于Netty的Web容器，并使用HandlerMapping组件初始化HttpPipelineInitializer管道，其中HandlerMapping如果未有用户定义则使用默认的DefaultHandlerMapping实现 public class DefaultHttpServer extends ApplicationObjectSupport { private static final Logger logger = LoggerFactory.getLogger(DefaultHttpServer.class); private static final String DEFAULT_HTTP_PORT = &quot;8080&quot;; private static final String HANDLER_MAPPING_BEAN_NAME = &quot;handlerMapping&quot;; private String port; private HandlerMapping handlerMapping; public void setPort(String port) { this.port = port; } @Override public void initApplicationContext(ApplicationContext applicationContext) { beforeInit(applicationContext); initHandlerMapping(applicationContext); initServer(); } void initHandlerMapping(ApplicationContext context) { try { this.handlerMapping = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); } catch (NoSuchBeanDefinitionException ex) { this.handlerMapping = context.getAutowireCapableBeanFactory().createBean(DefaultHandlerMapping.class); } } void initServer() { logger.debug(&quot;初始化服务器&quot;); if (!HttpUtils.isPort(port)) { logger.warn(&quot;端口号不合法，使用默认端口{}&quot;, DEFAULT_HTTP_PORT); port = DEFAULT_HTTP_PORT; } EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(Integer.parseInt(port))) .childHandler(new HttpPipelineInitializer(handlerMapping)); ChannelFuture f = b.bind().sync(); logger.info(&quot;服务启动成功，监听{}端口&quot;, port); f.channel().closeFuture().sync(); } catch (InterruptedException e) { e.printStackTrace(); } finally { try { workerGroup.shutdownGracefully().sync(); bossGroup.shutdownGracefully().sync(); } catch (InterruptedException e) { e.printStackTrace(); } } } protected void beforeInit(ApplicationContext applicationContext) { } } 提供默认的HandlerMapping实现类，负责匹配@RequestMapping注解下的处理函数 public class DefaultHandlerMapping extends ApplicationObjectSupport implements HandlerMapping { Logger logger = LoggerFactory.getLogger(DefaultHandlerMapping.class); private static Map&lt;String, HttpHandler&gt; httpHandlerMap = new HashMap&lt;String, HttpHandler&gt;(); @Override public void initApplicationContext(ApplicationContext context) throws BeansException { logger.debug(&quot;初始化处理匹配器&quot;); Map&lt;String, Object&gt; handles = context.getBeansWithAnnotation(Controller.class); try { for (Map.Entry&lt;String, Object&gt; entry : handles.entrySet()) { logger.debug(&quot;加载控制器{}&quot;, entry.getKey()); loadHttpHandler(entry.getValue()); } } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } } void loadHttpHandler(Object value) throws IllegalAccessException, InstantiationException { Class clazz = value.getClass(); Object clazzFromInstance = clazz.newInstance(); Method[] method = clazz.getDeclaredMethods(); for (Method m : method) { if (m.isAnnotationPresent(RequestMapping.class)) { RequestMapping requestMapping = m.getAnnotation(RequestMapping.class); for (String url : requestMapping.value()) { HttpHandler httpHandler = httpHandlerMap.get(url); if (httpHandler == null) { logger.info(&quot;加载url为{}的处理器{}&quot;, url, m.getName()); httpHandlerMap.put(url, new HttpHandler(clazzFromInstance, m)); } else { logger.warn(&quot;url{}存在相同的处理器&quot;, url); } } } } } @Override public HttpHandler getHadnler(FullHttpRequest request) { return httpHandlerMap.get(request.uri()); } } 当请求进入时通过HandlerMapping组件匹配处理器，如果匹配失败则返回404 public class AllocHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; { private HandlerMapping handlerMapping; public AllocHandler(HandlerMapping handlerMapping) { this.handlerMapping = handlerMapping; } /* 异常处理 */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { sendError(ctx, HttpResponseStatus.INTERNAL_SERVER_ERROR); super.exceptionCaught(ctx, cause); } @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest fullHttpRequest) throws Exception { HttpHandler httpHandler = handlerMapping.getHadnler(fullHttpRequest); if (httpHandler != null) { Object obj = httpHandler.execute(fullHttpRequest); if (obj instanceof String) { sendMessage(ctx, obj.toString()); } else { sendMessage(ctx, JSONObject.toJSONString(obj)); } } else { sendError(ctx, HttpResponseStatus.NOT_FOUND); } } private void sendMessage(ChannelHandlerContext ctx, String msg) { FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.copiedBuffer(msg, CharsetUtil.UTF_8)); response.headers().set(&quot;Content-Type&quot;, &quot;text/plain&quot;); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } private void sendError(ChannelHandlerContext ctx, HttpResponseStatus httpResponseStatus) { FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, httpResponseStatus, Unpooled.copiedBuffer(httpResponseStatus.toString(), CharsetUtil.UTF_8)); response.headers().set(&quot;Content-Type&quot;, &quot;text/plain&quot;); ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); } } 测试与使用 建立一个TestController @Controller public class TestController { @RequestMapping(&quot;/test&quot;) public String testHandler(FullHttpRequest fullHttpRequest) { return &quot;1234&quot;; } @RequestMapping(&quot;/zx&quot;) public String zx(FullHttpRequest fullHttpRequest) { return &quot;zhuxiong&quot;; } @RequestMapping(&quot;/obj&quot;) public Object obj(FullHttpRequest fullHttpRequest) { System.out.println(&quot;\\n\\n----------&quot;); HttpHeaders httpHeaders = fullHttpRequest.headers(); Set&lt;String&gt; names = httpHeaders.names(); for (String name : names) { System.out.println(name + &quot; : &quot; + httpHeaders.get(name)); } System.out.println(&quot;&quot;); ByteBuf byteBuf = fullHttpRequest.content(); byte[] byteArray = new byte[byteBuf.capacity()]; byteBuf.readBytes(byteArray); System.out.println(new String(byteArray)); System.out.println(&quot;----------\\n\\n&quot;); JSONObject json = new JSONObject(); json.put(&quot;errCode&quot;, &quot;00&quot;); json.put(&quot;errMsg&quot;, &quot;0000000(成功)&quot;); json.put(&quot;data&quot;, null); return json; } } 启动Spring容器 public class HttpServerTest { public static void main(String[] args) throws Exception { CettyBootstrap.create(); // CettyBootstrap.create(&quot;classpath:applicationContext.xml&quot;); } } 未来要做的 与Spring框架集成，将核心组件托管给Spring容器统一管理 提供静态资源映射 修改映射策略将请求映射至一个流程（一个处理器多个拦截器） 支持使用模板语法进行视图解析","link":"/2018-05-23-build-http-server-with-netty/"},{"title":"纯正后端的vue轮子笔记","text":"好记性不如烂笔头，多造轮子多做笔记 说明由于公司需要，我作为一个纯正的后端工程师，已经自学了半年多的vue了，愣是被逼成了一个小全栈，当然，小全栈这是往好听了说，事实上就是个前后端深度都不足的小菜鸡，在深知自己众多不足以及明白好记性不如烂笔头的道理下，多造轮子多做笔记总是不会错的：） 所以最近得空我把我刚学vuejs的时候写的烂工程重构了一下，重构的时候针对性的分模块做了一些笔记如下 路由 状态管理 权限管理 控件封装与使用 混入 数据模拟 打包优化与用户体验 如果不想拉这么长可以去 全球最大的同性交友网站 查看 进入烂笔头模式 路由 1-路由加载// 直接加载页面 import page from '@/views/page'; // 懒加载页面 () =&gt; import('@/views/page'); // 指定打包名称的懒加载，可将多个页面打包成一个js进行加载 () =&gt; import(/* webpackChunkName: &quot;group-page&quot; */'@/views/page1'); () =&gt; import(/* webpackChunkName: &quot;group-page&quot; */'@/views/page2'); () =&gt; import(/* webpackChunkName: &quot;group-page&quot; */'@/views/page3'); 2-404路由// 加载一个404页面 import page404 from '@/views/page404'; // 将以下路由配置放置在路由表的最末端，当路径无法匹配前面的所有路由时将会跳转至page404组件页面 { path: '*', component: page404} 3-路由拦截// 路由跳转前的拦截器 router.beforeEach((to, from, next) =&gt; { }); // 路由跳转后的拦截器 router.afterEach(to =&gt; { }); // 路由跳转时出现错误时的拦截器 router.onError((err) =&gt; { }); 4-动态路由 动态路由一般配合页面级的权限控制使用 // 通过router.addRoutes方法动态添加可访问路由 router.addRoutes(addRouters) // hack方法 确保addRoutes已完成 next({ ...to, replace: true }) // set the replace: true so the navigation will not leave a history record 5-路由加载时动画 路由加载时的loading动画一般配合路由懒加载使用 // 在状态管理中定义一个路由loading标志 const app = { state: { routerLoading: false, //路由的loading过渡 }, mutations: { //修改路由loading状态 UPDATE_ROUTER_LOADING(state, status) { state.routerLoading = status } } } // 在路由拦截器中修改loading状态 router.beforeEach((to, from, next) =&gt; { store.commit('UPDATE_ROUTER_LOADING', true); // 展示路由加载时动画 }); router.afterEach(to =&gt; { store.commit('UPDATE_ROUTER_LOADING', false); }); router.onError(err =&gt; { console.error(err); // for bug store.commit('UPDATE_ROUTER_LOADING', false); }); // 在router-view定义loading动画 // element-ui提供了v-loading指令可以直接使用 &lt;router-view v-loading=&quot;$store.getters.routerLoading&quot;&gt;&lt;/router-view&gt; 状态管理 1-小知识 state中的数据修改需要通过mutation或action触发 mutation中的方法必须是同步函数 action可包含任意异步操作，可返回一个Promise mutation以及action可以重复，调用时将会依次调用，getter必须唯一 2-多模块 业务比较复杂时可使用状态管理中的多模块，有以下注意事项 除state会根据组合时模块的别名来添加层级，其他的都是合并在根级下，所以在回调函数获取的getters、commit、dispatch都是全局作用的 mutation的回调参数只有state，state为当前模块的状态树，下同 action的回调参数为state、rootState、getters、commit、dispatch，如果需要在action中调用其他的action可使用dispatch直接调用 getter的回调参数为state、rootState、getters 模块间可以通过回调的rootState进行交互 出现重名的mutation、action将依次触发// 多模块的实现 app以及user为各个子模块 export default new Vuex.Store({ modules: { app, user }, getters }) 3-辅助函数 Vuex除了提供了Store对象以外还对外提供了一些辅助函数 mapState、mapGetters将store中的state、getters属性映射到vue组件局部的计算属性中 import { mapState } from 'vuex' computed: mapState([ // 映射 this.name 到 this.$store.state.name 'name' ]) import { mapGetters } from 'vuex' computed: { // 映射 this.name 到 this.$store.getters.name ...mapGetters([ 'name' ]) } mapActions、mapMutations将store中的dispatch、commit方法映射到vue组件局部的方法中 import { mapActions } from 'vuex' methods: { // 映射 this.LoginByUsername() 到 this.$store.dispatch('LoginByUsername') ...mapActions([ 'LoginByUsername' ]), // 映射 this.login() to this.$store.dispatch('LoginByUsername') ...mapActions({ login: 'LoginByUsername'}) } import { mapMutations } from 'vuex' methods: { // 映射 this.SET_NAME() 到 this.$store.commit('SET_NAME') ]) ...mapMutations([ 'SET_NAME' ]) , // 映射 this.setName() 到 this.$store.commit('SET_NAME') }) ...mapMutations({ setName: 'SET_NAME' ]) } 4-数据持久化插件 刷新页面时希望状态不被丢失时可用此插件 // 摘抄于 https://github.com/robinvdvleuten/vuex-persistedstate import createPersistedState from 'vuex-persistedstate' import * as Cookies from 'js-cookie' const store = new Store({ // ... plugins: [ createPersistedState({ storage: { getItem: key =* Cookies.get(key), // Please see https://github.com/js-cookie/js-cookie#json, on how to handle JSON. setItem: (key, value) =* Cookies.set(key, value, { expires: 3, secure: true }), removeItem: key =* Cookies.remove(key) } }) ] }) 5-日志插件 开发环境中希望能够跟踪状态变化并输出时可用此插件 // createLogger是vuex中的内置插件 import createLogger from 'vuex/dist/logger' let vuexPlugins = []; if(process.env.NODE_ENV !== 'production'){ // 开发环境加载该插件 vuexPlugins.push(createLogger); } const store = new Store({ // ... plugins: vuexPlugins }) 权限管理 1-需要实现的功能 根据用户登录后的权限表生成路由 页面级的权限控制 dom元素级的权限控制 登录状态失效的处理 2-路由设计 首先我们需要设计路由对象需要有哪些必要参数信息 为了实现权限管理我们必须要有roles参数代表该路由必须拥有哪些权限才能访问 为了更好的展示路由在这里设计了title、icon两个参数用于侧边栏的菜单展示 而有些路由不需要在侧边栏展示，这里使用hidden参数来告诉程序哪些路由是不需要展示的 // 首先设计路由对象参数 /** * hidden: true 如果hidden为true则在左侧菜单栏展示，默认为false * name:'router-name' 路由名称，路由唯一标识 * meta : { roles: ['admin','editor'] 权限列表，用于页面级的权限控制，默认不设置代表任何权限均可访问 title: 'title' 对应路由在左侧菜单栏的标题名称 icon: 'icon-class' 对应路由在左侧菜单栏的图标样式 } **/ 接下来我们需要实现路由的动态加载 系统初始化时加载必要路由，之后根据登录用户的权限加载符合条件的路由 // 定义系统初始化时加载的必要路由信息 export const constantRouterMap = [ { path: '/login', name: 'login', meta: { title: &quot;系统登录&quot;, hidden: true }, component: login }, { path: &quot;/404&quot;, name: &quot;page404&quot;, meta: { title: &quot;页面走丢了&quot;, hidden: true }, component: page404 }, { path: &quot;/401&quot;, name: &quot;page401&quot;, meta: { title: &quot;权限不足&quot;, hidden: true }, component: page401 } ] // 定义布局页面 const layout = () =&gt; import(/* webpackChunkName: &quot;group-index&quot; */ '@/views/layout'); // 定义异步加载的路由信息 export const asyncRouterMap = [ { path: '/', name: 'main', redirect: '/dashboard', hidden: true, component: layout, children: [ { path: 'dashboard', name: 'dashboard', meta: { title: &quot;仪表盘&quot; }, component: () =&gt; import(/* webpackChunkName: &quot;group-index&quot; */'@/views/dashboard') } ] }, { path: '/permission', name: 'permission', meta: { title: &quot;权限页&quot;, icon: &quot;dbm d-icon-quanxian&quot; }, redirect: '/permission/adminpermission', component: layout, children: [ { path: &quot;adminpermission&quot;, name: &quot;adminPermission&quot;, meta: { title: &quot;管理员权限页&quot;, roles: [&quot;admin&quot;] }, component: () =&gt; import('@/views/permission/admin') }, { path: &quot;watcherpermission&quot;, name: &quot;watcherPermission&quot;, meta: { title: &quot;游客权限页&quot;, roles: [&quot;admin&quot;, &quot;watcher&quot;] }, component: () =&gt; import('@/views/permission/watcher') }, { path: &quot;elementpermission&quot;, name: &quot;elementPermission&quot;, meta: { title: &quot;元素级别权限&quot; }, component: () =&gt; import('@/views/permission/element') } ] }, { path: '*', redirect: '/404', hidden: true } ] 3-页面级的权限控制 使用路由拦截来实现页面级的权限控制 拦截路由跳转判断用户是否登录 从拉取的用户信息中提取权限表通过addRoutes方法动态加载异步路由表 每次路由跳转时判断用户是否拥有该路由的访问权限实现动态权限匹配 // 定义免登白名单 const whiteList = ['/login', '/404', '/401']; // 拦截路由跳转 router.beforeEach((to, from, next) =&gt; { store.commit('UPDATE_ROUTER_LOADING', true); // 展示路由加载时动画 if (getToken()) { // 存在token if (to.path === '/login') { next({ path: '/' }) } else { if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完用户信息 store.dispatch('GetUserInfo').then(data =&gt; { // 拉取用户信息 const roles = data.roles // 权限表必须为数组,例如: ['admin','editer'] store.dispatch('GenerateRoutes', { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record }) }).catch(err =&gt; { // 拉取用户信息失败，提示登录状态失效 store.dispatch('FedLogOut').then(() =&gt; { Message.error('登录状态失效, 请重新登录'); next({ path: '/login' }); }) }) } else { if (hasPermission(store.getters.roles, to.meta.roles)) { // 动态权限匹配 next(); } else { next({ path: '/401', replace: true, query: { noGoBack: true } }); } } } } else { // 没有token if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next(); } else { next('/login'); // 否则全部重定向到登录页 } } }); 4-元素级的权限控制 使用自定义指令来实现元素级的权限控制 在被绑定元素插入父节点时验证用户是否包含该元素的所需权限 根据鉴权结果来决定是否移除该元素 import store from '@/store' export default { inserted(el, binding, vnode) { const { value } = binding; // 获取自定义指令传入的鉴权信息 const roles = store.getters &amp;&amp; store.getters.roles; // 从状态管理中获取当前用户的路由信息 if (value &amp;&amp; value instanceof Array &amp;&amp; value.length &gt; 0) { const permissionRoles = value; const hasPermission = roles.some(role =&gt; { // 判断用户是否包含该元素所需权限 return permissionRoles.includes(role); }) if (!hasPermission) { // 权限不足 el.parentNode &amp;&amp; el.parentNode.removeChild(el); // 移除该dom元素 } } else { throw new Error(`必须要有权限写入，例如['admin']`) } } } // 在vue组件上使用它 // 引入并注册permission指令 import permission from &quot;@/directive/permission/index.js&quot;; export default { directives: { permission } } // 使用permission指令 &lt;el-button v-permission=&quot;['admin']&quot;&gt;admin 可见&lt;/el-button&gt; &lt;el-button v-permission=&quot;['admin','watcher']&quot;&gt;watcher 可见&lt;/el-button&gt; render函数 1-如何封装一个支持render渲染的组件 首先创建一个函数式组件 // 表格拓展函数式组件的实现 // see https://github.com/calebman/vue-DBM/blob/master/src/components/table/expand.js export default { name: 'TableExpand', functional: true, // 标记组件为 functional，这意味它是无状态 (没有响应式数据)，无实例 (没有 this 上下文)。 props: { row: Object, // 当前行对象 field: String, // 列名称 index: Number, // 行号 render: Function // 渲染函数 }, render: (h, ctx) =&gt; { // 提供ctx作为上下文 const params = { row: ctx.props.row, field: ctx.props.field, index: ctx.props.index }; return ctx.props.render(h, params); } }; 在父组件中引入 // see https://github.com/calebman/vue-DBM/blob/master/src/components/table/table.vue import expand from &quot;./expand.js&quot;; &lt;span v-if=&quot;typeof col.render ==='function'&quot;&gt; &lt;expand :field=&quot;col.field&quot; :row=&quot;item&quot; :render=&quot;col.render&quot; :index=&quot;rowIndex&quot;&gt;&lt;/expand&gt; &lt;/span&gt; 使用render函数渲染 // see https://github.com/calebman/vue-DBM/blob/master/src/views/demo/datatable/data-table.vue // 引入自定义组件 import IndexColumn from &quot;@/components/business/index-column.vue&quot;; // 注册 components: { // ... IndexColumn } // 使用 // 获取当前组件的上下文 let self = this; // 定义渲染函数 render: (h, params) =&gt; h(&quot;div&quot;, [ h(IndexColumn, { props: { field: params.field, index: params.index, pagingIndex: (self.pagination.pageCurrent - 1) * self.pagination.pageSize }, on: { &quot;on-value-delete&quot;: self.deleteRow } }) ]) 混入 1-小知识-1 混入对象将享有被混入组件的生命周期 数据对象混入冲突时将以组件数据优先 对象选项（如methods、components、directives）混入冲突时取组件对象的键值对 同名钩子混合为数组，混入对象的钩子将在组件自身钩子之前调用 2-应用场景 希望部分路由页面在离开时销毁但是不希望每个路由页面都定义局部路由时 // 定义混入对象 export default { beforeRouteLeave(to, from, next) { if (to.meta &amp;&amp; to.meta.destroy) { this.$destroy(); } next(); } } // 混入需要此功能的组件页面 import routeLeaveDestoryMixin from &quot;routeleave-destory-mixin&quot;; export default { // ... mixins: [routeLeaveDestoryMixin] } 数据表格自定义了文本、数字、时间以及文件单元格组件，每个组件都有同样的数据修改、焦点选中等方法时，可提取为混入对象，提高组件复用性 // see https://github.com/calebman/vue-DBM/blob/master/src/components/business/render-column-mixin.js // 定义混入对象 export default { // ... computed: { // 是否选中此单元格 inSelect() { if (this.cellClickData.index == this.index &amp;&amp; this.cellClickData.field == this.field) { this.focus(); return true; } } }, methods: { // 获取焦点 focus() { let self = this; setTimeout(function () { if (self.$refs[&quot;rendercolumn&quot;]) { self.$refs[&quot;rendercolumn&quot;].focus(); } }, 100); }, // 失去焦点 blur() { if (this.v != this.value) { this.$emit(&quot;on-value-change&quot;, this.field, this.index, this.v); } this.$emit(&quot;on-value-cancel&quot;, this.field, this.index); }, // 数据修改 changeValue(val) { this.$emit(&quot;on-value-change&quot;, this.field, this.index, val); this.$emit(&quot;on-value-cancel&quot;, this.field, this.index); } }, watch: { // 监听父组件数据变化 value(val) { this.v = val; } } } // 文本列 // see https://github.com/calebman/vue-DBM/blob/master/src/components/business/text-column.vue &lt;template&gt; &lt;div&gt; &lt;input v-show=&quot;inSelect&quot; ref=&quot;rendercolumn&quot; @blur=&quot;blur&quot; @keyup=&quot;enter($event)&quot; v-model=&quot;v&quot; /&gt; &lt;span v-show=&quot;!inSelect&quot; class=&quot;cell-text&quot;&gt;{{v}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; // 时间列 // see https://github.com/calebman/vue-DBM/blob/master/src/components/business/datetime-column.vue &lt;template&gt; &lt;div&gt; &lt;el-date-picker v-show=&quot;inSelect&quot; ref=&quot;rendercolumn&quot; v-model=&quot;v&quot; type=&quot;datetime&quot; @change=&quot;changeValue&quot; @blur=&quot;blur&quot;&gt;&lt;/el-date-picker&gt; &lt;span v-show=&quot;!inSelect&quot;&gt;{{coverValue}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; 希望降低组件的复杂度的时候可使用多个混入组件来分割核心组件的功能 # see https://github.com/calebman/vue-DBM/tree/master/src/components/table ├─table │ cell-edit-mixin.js # 单元格编辑 │ classes-mixin.js # 表格样式 │ scroll-bar-control-mixin.js # 表格滚动 │ table-empty-mixin.js # 无数据时的处理 │ table-resize-mixin.js # 表格的自适应 │ table-row-mouse-events-mixin.js # 鼠标移动时的样式改变 数据模拟 1-需要实现的功能-1 拦截Ajax请求并延时响应 返回的统一的数据格式 响应不同的模拟数据 2-配置Mockjs拦截Ajax请求// see https://github.com/calebman/vue-DBM/blob/master/src/mock/index.js // 引入Mockjs import Mock from 'mockjs'; // 配置延时 Mock.setup({ timeout: '300-1000' }); // 配置拦截 Mock.mock(/\\/user\\/login/, 'post', loginAPI.loginByUsername); Mock.mock(/\\/user\\/logout/, 'post', loginAPI.logout); Mock.mock(/\\/user\\/info\\.*/, 'get', loginAPI.getUserInfo); 3-响应的统一数据格式// see https://github.com/calebman/vue-DBM/blob/master/src/mock/response.js /** * 统一响应工具类 * 响应统一格式的数据 * response : { * errCode: 00 响应结果码 * errMsg: 0000000（成功） 响应详细结果码 * data: null 具体数据 * } */ export default { // 成功 success: data =&gt; { return { errCode: '00', errMsg: '0000000（成功）', data: data ? data : null } }, // 失败 fail: (errCode, errMsg) =&gt; { return { errCode: errCode ? errCode : '04', errMsg: errMsg ? errMsg : '0401001（未知错误）', data: null } }, // 权限不足 unauthorized: () =&gt; { return { errCode: '43', errMsg: '4300001（无权访问）', data: null } } } 4-配置响应逻辑// see https://github.com/calebman/vue-DBM/blob/master/src/mock/login.js import { param2Obj } from '@/utils'; import Response from './response'; const userMap = { admin: { password: 'admin', roles: ['admin'], token: 'admin', introduction: '我是超级管理员', avatar: 'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif', name: 'Super Admin' }, watcher: { password: 'watcher', roles: ['watcher'], token: 'watcher', introduction: '我是游客', avatar: 'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif', name: 'Normal Watcher' } } export default { // 使用用户名登录 loginByUsername: config =&gt; { const { username, password } = JSON.parse(config.body); if (userMap[username] &amp;&amp; userMap[username].password === password) { return Response.success(userMap[username]); } else { return Response.fail(&quot;01&quot;, &quot;0101001（用户名或密码错误）&quot;) } }, // 拉取用户信息 getUserInfo: config =&gt; { const { token } = param2Obj(config.url); if (userMap[token]) { return Response.success(userMap[token]); } else { return Response.fail(); } }, // 注销 logout: () =&gt; Response.success() } 5-模拟随机数据// see https://github.com/nuysoft/Mock/wiki import Mock from 'mockjs'; // 随机字符串 function mockStr() { let result = Mock.mock({ 'str': '@name' }); return result.str; } // 随机数字 function mockNumber(min, max) { let key = 'num|' + min + '-' + max; let param = {} param[key] = 100; return Mock.mock(param).num; } // 随机小数，最高小数点后三位 function mockDecimal() { return Mock.Random.float(1, 100, 1, 3) } // 随机数组一项 const arr = [&quot;image2.jpeg&quot;, &quot;image3.jpeg&quot;, &quot;image4.jpeg&quot;, &quot;image5.jpeg&quot;, &quot;image6.jpeg&quot;]; function mockOneFileAddress() { return Mock.mock({ 'oneFile|1': arr }).oneFile; } // 随机日期 function mockDate() { let mockDateStr = Mock.Random.datetime('yyyy-MM-dd HH:mm:ss'); // 在这里使用了momentjs将其解析为Date类型 let mockDate = moment(mockDateStr, 'YYYY-MM-DD HH:mm:ss').toDate(); return mockDate; } 打包优化 1-做哪部分的优化 cdn优化 路由懒加载 其他优化 用户体验 2-cdn优化 类似于vue、vue-router、moment、element-ui等提供了cdn的架或者工具类可在index.html中直接引入，然后配置webpack的externals使其不加入打包配置，从而减小app.js、vendor.js的体积 在index.html使用cdn引入依赖库 &lt;!-- 网络请求工具类 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt; &lt;!-- vue --&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.min.js&quot;&gt;&lt;/script&gt; &lt;!-- vue-router --&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;!-- vuex --&gt; &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.0.1/vuex.min.js&quot;&gt;&lt;/script&gt; &lt;!-- momentjs的中文包 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/moment.js/2.22.1/moment-with-locales.min.js&quot;&gt;&lt;/script&gt; &lt;!-- momentjs --&gt; &lt;script src=&quot;https://cdn.bootcss.com/moment.js/2.22.1/locale/zh-cn.js&quot;&gt;&lt;/script&gt; &lt;!-- element-ui样式 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.3.6/theme-default/index.css&quot;&gt;&lt;/script&gt; &lt;!-- element-ui --&gt; &lt;script src=&quot;https://cdn.bootcss.com/element-ui/2.3.6/index.js&quot;&gt;&lt;/script&gt; 配置build文件夹下webpack.base.conf.js文件 module.exports = { // ... externals: { 'axios': 'axios', 'vue': 'Vue', 'vue-router': 'VueRouter', 'vuex': 'Vuex', 'moment': 'moment', 'element-ui': 'ELEMENT' } } 3-路由懒加载 路由懒加载能够将代码根据路由配置进行分割，加快首屏渲染的速度，在大型的单页应用中是必不可少的 参见路由管理的实现 5-其他优化 尽量少的注册全局组件，使用UI框架可以参考文档做按需加载 可以和服务端配合采用gzip压缩，减少传输耗时 在更新不是很频繁的应用可考虑提高缓存时间 例如moment、lodash这种庞大的工具库在使用的功能不多的情况下可考虑寻找替代品 6-用户体验 一个单页应用到了一定规模不管怎么优化首屏渲染还是一个比较慢的过程，此时可以考虑在首屏渲染时使用一个加载动画告诉用户系统正在初始化 首先在index.html中定义一个渲染动画 &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- 首屏渲染时的加载动画 --&gt; &lt;div id=&quot;system-loading&quot; class=&quot;showbox&quot;&gt; &lt;div class=&quot;loader&quot;&gt; &lt;svg class=&quot;circular&quot; viewBox=&quot;25 25 50 50&quot;&gt; &lt;circle class=&quot;path&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;20&quot; fill=&quot;none&quot; stroke-width=&quot;2&quot; stroke-miterlimit=&quot;10&quot; /&gt; &lt;/svg&gt; &lt;/div&gt; &lt;div class=&quot;text&quot;&gt; &lt;span&gt;系统初始化中...&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;/body&gt; 然后在App.vue组件的mounted钩子中移除这个loading export default { // ... mounted() { document.body.removeChild(document.getElementById(&quot;system-loading&quot;)); } };","link":"/2018-05-18-vue-notes/"},{"title":"SpringBoot集成环境搭建","text":"一个高可复用的SpringBoot基础框架 本文简介 为什么使用SpringBoot 搭建怎样一个环境 开发环境 导入快速启动项目 集成前准备 集成Mybatis 集成Swagger2 多环境配置 多环境下的日志配置 常用配置 为什么使用SpringBoot&emsp;&emsp; SpringBoot相对于传统的SSM框架的优点是提供了默认的样板化配置，简化了Spring应用的初始搭建过程，如果你不想被众多的xml配置文件困扰，可以考虑使用SpringBoot替代 搭建怎样一个环境&emsp;&emsp; 本文将基于Spring官方提供的快速启动项目模板集成Mybatis、Swagger2框架，并讲解mybatis generator一键生成代码插件、logback、一键生成文档以及多环境的配置方法，最后再介绍一下自定义配置的注解获取、全局异常处理等经常用到的东西。 开发环境&emsp;&emsp; 本人使用IDEA作为开发工具，IDEA下载时默认集成了SpringBoot的快速启动项目可以直接创建，如果使用Eclipse的同学可以考虑安装SpringBoot插件或者直接从这里配置并下载SpringBoot快速启动项目，需要注意的是本次环境搭建选择的是SpringBoot2.0的快速启动框架，SpringBoot2.0要求jdk版本必须要在1.8及以上。 导入快速启动项目&emsp;&emsp; 不管是由IDEA导入还是现实下载模板工程都需要初始化快速启动工程的配置，如果使用IDEA，在新建项目时选择Spring Initializr，主要配置如下图&emsp;&emsp; 点击next之后finish之后IDEA显示正在下载模板工程，下载完成后会根据pom.xml下载包依赖，依赖下载完毕后模板项目就算创建成功了，如果是直接从官方网站配置下载快速启动项目可参考下图配置&emsp;&emsp; 从Search for dependencies 框中输入并选择Web、Mysql、Mybatis加入依赖，点击Generate Project下载快速启动项目，然后在IDE中选择导入Maven项目，项目导入完成后可见其目录结构如下图&emsp;&emsp; 需要关注红色方框圈起来的部分，由上往下第一个java类是用来启动项目的入口函数，第二个properties后缀的文件是项目的配置文件，第三个是项目的依赖包以及执行插件的配置 集成前准备修改-properties为-yml&emsp;&emsp; yml相对于properties更加精简而且很多官方给出的Demo都是yml的配置形式，在这里我们采用yml的形式代替properties，相对于properties形式主要有以下两点不同 对于键的描述由原有的 “.” 分割变成了树的形状 对于所有的键的后面一个要跟一个空格，不然启动项目会报配置解析错误 # properties式语法描述 spring.datasource.name = mysql spring.datasource.url = jdbc:mysql://localhost:3306/db?characterEncoding=utf-8 spring.datasource.username = root spring.datasource.password = 123 # yml式语法描述 spring: datasource: name: mysql url: jdbc:mysql://localhost:3306/db?characterEncoding=utf-8 username: root password: 123 配置所需依赖&emsp;&emsp; 快速启动项目创建成功后我们观察其pom.xml文件中的依赖如下图，包含了我们选择的Web、Mybatis以及Mysql &lt;!-- spring web mvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &emsp;&emsp; 但是我们使用ORM框架一般还会配合数据库连接池以及分页插件来使用，在这里我选择了阿里的druid以及pagehelper这个分页插件，再加上我们还需要整合swagger2文档自动化构建框架，所以增加了以下四个依赖项 &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的json格式化对象 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.31&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 自动生成API文档 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.5.0&lt;/version&gt; &lt;/dependency&gt; 集成Mybatis&emsp;&emsp; Mybatis的配置主要包括了druid数据库连接池、pagehelper分页插件、mybatis-generator代码逆向生成插件以及mapper、pojo扫描配置 配置druid数据库连接池&emsp;&emsp; 添加以下配置至application.yml文件中 spring: datasource: # 如果存在多个数据源，监控的时候可以通过名字来区分开来 name: mysql # 连接数据库的url url: jdbc:mysql://localhost:3306/db?characterEncoding=utf-8 # 连接数据库的账号 username: root # 连接数据库的密码 password: 123 # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource # 扩展插件 # 监控统计用的filter:stat 日志用的filter:log4j 防御sql注入的filter:wall filters: stat # 最大连接池数量 maxActive: 20 # 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 initialSize: 1 # 获取连接时最大等待时间，单位毫秒 maxWait: 60000 # 最小连接池数量 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 # 连接保持空闲而不被驱逐的最长时间 minEvictableIdleTimeMillis: 300000 # 用来检测连接是否有效的sql，要求是一个查询语句 # 如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用 validationQuery: select count(1) from 'table' # 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效 testWhileIdle: true # 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnBorrow: false # 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testOnReturn: false # 是否缓存preparedStatement，即PSCache poolPreparedStatements: false # 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true maxOpenPreparedStatements: -1 配置pagehelper分页插件# pagehelper分页插件 pagehelper: # 数据库的方言 helperDialect: mysql # 启用合理化，如果pageNum &lt; 1会查询第一页，如果pageNum &gt; pages会查询最后一页 reasonable: true 代码逆向生成插件mybatis-generator的配置及运行&emsp;&emsp; mybatis-generator插件的使用主要分为以下三步 pom.xml中添加mybatis-generator插件 &lt;build&gt; &lt;plugins&gt; &lt;!-- 将Spring Boot应用打包为可执行的jar或war文件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 扫描resources/generator目录下的generatorConfig.xml配置 --&gt; &lt;configurationFile&gt; ${basedir}/src/main/resources/generator/generatorConfig.xml &lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2.创建逆向代码生成配置文件generatorConfig.xml &emsp;&emsp; 参照pom.xml插件配置中的扫描位置，在resources目录下创建generator文件夹，在新建的文件夹中创建generatorConfig.xml配置文件，文件的详细配置信息如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- 运行方式:mvaen运行命令 mybatis-generator:generate -e --&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;properties resource=&quot;generator/generator.properties&quot;/&gt; &lt;classPathEntry location=&quot;${classPathEntry}&quot;/&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/${db}?characterEncoding=utf-8&quot; userId=&quot;${userId}&quot; password=&quot;${password}&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage=&quot;${pojoTargetPackage}&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage=&quot;${mapperTargetPackage}&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;${daoTargetPackage}&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 schema是数据库名称--&gt; &lt;table tableName=&quot;%&quot; schema=&quot;${db}&quot;/&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; &emsp;&emsp; 为了将generatorConfig.xml配置模板化，在这里将变动性较大的配置项单独提取出来作为一个generatorConfig.xml的配置文件，然后通过properties标签读取此文件的配置，这样做的好处是当需要多处复用此xml时只需要关注少量的配置项。&emsp;&emsp; 在generatorConfig.xml同级创建generator.properties文件，现只需要配置generator.properties文件即可，配置内容如下 # 请手动配置以下选项 # 数据库驱动:选择你的本地硬盘上面的数据库驱动包 classPathEntry = D:/CJH/maven-repository/mysql/mysql-connector-java/5.1.30/mysql-connector-java-5.1.30.jar # 数据库名称、用户名、密码 db = db userId = root password = 123 # 生成pojo的包名位置 在src/main/java目录下 pojoTargetPackage = com.spring.demo.springbootexample.mybatis.po # 生成DAO的包名位置 在src/main/java目录下 daoTargetPackage = com.spring.demo.springbootexample.mybatis.mapper # 生成Mapper的包名位置 位于src/main/resources目录下 mapperTargetPackage = mapper 运行mybatis-generator插件生成Dao、Model、Mapping # 打开命令行cd到项目pom.xml同级目录运行以下命令 mvn mybatis-generator:generate -e mybatis扫描包配置&emsp;&emsp; 至此已经生成了指定数据库对应的实体、映射类，但是还不能直接使用，需要配置mybatis扫描地址后才能正常调用 在application.yml配置mapper.xml以及pojo的包地址 mybatis: # mapper.xml包地址 mapper-locations: classpath:mapper/*.xml # pojo生成包地址 type-aliases-package: com.spring.demo.springbootexample.mybatis.po 在SpringBootExampleApplication.java中开启Mapper扫描注解 @SpringBootApplication @MapperScan(&quot;com.spring.demo.springbootexample.mybatis.mapper&quot;) public class SpringBootExampleApplication { public static void main(String[] args) { SpringApplication.run(SpringBootExampleApplication.class, args); } } 测试mapper的有效性@Controller public class TestController { //替换成自己生成的mapper @Autowired UserMapper userMapper; @RequestMapping(&quot;/test&quot;) @ResponseBody public Object test(){ //查询该表的所有数据 return userMapper.selectByExample(null); } } &emsp;&emsp; 启动SpringBootExampleApplication.java的main函数，如果没有在application.yml特意配置server.port那么springboot会采用默认的8080端口运行，运行成功将打印如下日志 Tomcat started on port(s): 8080 (http) with context path '' 在浏览器输入地址如果返回表格的中的所有数据代表mybatis集成成功 http://localhost:8080/test 集成Swagger2&emsp;&emsp; Swagger2是一个文档快速构建工具，能够通过注解自动生成一个Restful风格json形式的接口文档，并可以通过如swagger-ui等工具生成html网页形式的接口文档，swagger2的集成比较简单，使用需要稍微熟悉一下，集成、注解与使用分如下四步 建立SwaggerConfig文件 @Configuration public class SwaggerConfig { // 接口版本号 private final String version = &quot;1.0&quot;; // 接口大标题 private final String title = &quot;SpringBoot示例工程&quot;; // 具体的描述 private final String description = &quot;API文档自动生成示例&quot;; // 服务说明url private final String termsOfServiceUrl = &quot;http://www.kingeid.com&quot;; // licence private final String license = &quot;MIT&quot;; // licnce url private final String licenseUrl = &quot;https://mit-license.org/&quot;; // 接口作者联系方式 private final Contact contact = new Contact(&quot;calebman&quot;, &quot;https://github.com/calebman&quot;, &quot;chenjianhui0428@gmail.com&quot;); @Bean public Docket buildDocket() { return new Docket(DocumentationType.SWAGGER_2).apiInfo(buildApiInf()) .select().build(); } private ApiInfo buildApiInf() { return new ApiInfoBuilder().title(title).termsOfServiceUrl(termsOfServiceUrl).description(description) .version(version).license(license).licenseUrl(licenseUrl).contact(contact).build(); } } 在SpringBootExampleApplication.java中启用Swagger2注解 &emsp;&emsp; 在@SpringBootApplication注解下面加上@EnableSwagger2注解 常用注解示例 //Contorller中的注解示例 @Controller @RequestMapping(&quot;/v1/product&quot;) // 表示标识这个类是swagger的资源 @Api(value = &quot;DocController&quot;, tags = {&quot;restful api示例&quot;}) public class DocController extends BaseController { @RequestMapping(value = &quot;/{id}&quot;, method = RequestMethod.PUT) @ResponseBody //表示一个http请求的操作 @ApiOperation(value = &quot;修改指定产品&quot;, httpMethod = &quot;PUT&quot;, produces = &quot;application/json&quot;) //@ApiImplicitParams用于方法，包含多个@ApiImplicitParam表示单独的请求参数 @ApiImplicitParams({@ApiImplicitParam(name = &quot;id&quot;, value = &quot;产品ID&quot;, required = true, paramType = &quot;path&quot;)}) public WebResult update(@PathVariable(&quot;id&quot;) Integer id, @ModelAttribute Product product) { logger.debug(&quot;修改指定产品接收产品id与产品信息=&gt;%d,{}&quot;, id, product); if (id == null || &quot;&quot;.equals(id)) { logger.debug(&quot;产品id不能为空&quot;); return WebResult.error(ERRORDetail.RC_0101001); } return WebResult.success(); } } //Model中的注解示例 //表示对类进行说明，用于参数用实体类接收 @ApiModel(value = &quot;产品信息&quot;) public class Product { //表示对model属性的说明或者数据操作更改 @ApiModelProperty(required = true, name = &quot;name&quot;, value = &quot;产品名称&quot;, dataType = &quot;query&quot;) private String name; @ApiModelProperty(name = &quot;type&quot;, value = &quot;产品类型&quot;, dataType = &quot;query&quot;) private String type; } 生成json形式的文档 &emsp;&emsp; 集成成功后启动项目控制台会打印级别为INFO的日志，截取部分如下，表明可通过访问应用的v2/api-docs接口得到文档api的json格式数据，可在浏览器输入指定地址验证集成是否成功 Mapped &quot;{[/v2/api-docs],methods=[GET],produces=[application/json || application/hal+json]}&quot; http://localhost:8080/v2/api-docs多环境配置&emsp;&emsp; 应用研发过程中多环境是不可避免的，假设我们现在有开发、演示、生产三个不同的环境其配置也不同，如果每次都在打包环节来进行配置难免出错，SpringBoot支持通过命令启动不同的环境，但是配置文件需要满足application-{profile}.properties的格式，profile代表对应环境的标识，加载时可通过不同命令加载不同环境。 application-dev.properties：开发环境 application-test.properties：演示环境 application-prod.properties：生产环境 # 运行演示环境命令 java -jar spring-boot-example-0.0.1-SNAPSHOT --spring.profiles.active=test &emsp;&emsp; 基于现在的项目实现多环境我们需要在application.yml同级目录新建application-dev.yml、application-test.yml、application-prod.yml三个不同环境的配置文件，将不变的公有配置如druid的大部分、pagehelper分页插件以及mybatis包扫描配置放置于application.yml中，并在application.yml中配置默认采用开发环境，那么如果不带–spring.profiles.active启动应用就默认为开发环境启动，变动较大的配置如数据库的账号密码分别写入不同环境的配置文件中 spring: profiles: # 默认使用开发环境 active: dev &emsp;&emsp; 配置到这里我们的项目目录结构如下图所示 &emsp;&emsp; 至此我们分别完成了Mybatis、Swagger2以及多环境的集成，接下来我们配置多环境下的logger。对于logger我们总是希望在项目研发过程中越多越好，能够给予足够的信息定位bug，项目处于演示或者上线状态时为了不让日志打印影响程序性能我们只需要警告或者错误的日志，并且需要写入文件，那么接下来就基于logback实现多环境下的日志配置 多环境下的日志配置&emsp;&emsp; 创建logback-spring.xml在application.yml的同级目录，springboot推荐使用logback-spring.xml而不是logback.xml文件，logback-spring.xml的配置内容如下所示 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt; &lt;!-- 简要描述 日志格式 =&gt; %d{HH:mm:ss.SSS}(时间) [%-5level](日志级别) %logger{36}(logger名字最长36个字符，否则按照句点分割) - %msg%n(具体日志信息并且换行) 开发环境 =&gt; ${basepackage}包下控制台打印DEBUG级别及以上、其他包控制台打印INFO级别及以上 演示（测试）环境 =&gt; ${basepackage}包下控制台打印INFO级别及以上、其他包控制台以及文件打印WARN级别及以上 生产环境 =&gt; 控制台以及文件打印ERROR级别及以上 日志文件生成规则如下： 文件生成目录 =&gt; ${logdir} 当日的log文件名称 =&gt; ${appname}.log 其他时候的log文件名称 =&gt; ${appname}.%d{yyyy-MM-dd}.log 日志文件最大 =&gt; ${maxsize} 最多保留 =&gt; ${maxdays}天 --&gt; &lt;!--自定义参数 --&gt; &lt;!--用来指定日志文件的上限大小，那么到了这个值，就会删除旧的日志--&gt; &lt;property name=&quot;maxsize&quot; value=&quot;30MB&quot; /&gt; &lt;!--只保留最近90天的日志--&gt; &lt;property name=&quot;maxdays&quot; value=&quot;90&quot; /&gt; &lt;!--application.yml 传递参数 --&gt; &lt;!--log文件生成目录--&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;logdir&quot; source=&quot;resources.logdir&quot;/&gt; &lt;!--应用名称--&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;appname&quot; source=&quot;resources.appname&quot;/&gt; &lt;!--项目基础包--&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;basepackage&quot; source=&quot;resources.basepackage&quot;/&gt; &lt;!--输出到控制台 ConsoleAppender--&gt; &lt;appender name=&quot;consoleLog&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--展示格式 layout--&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;pattern&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%-5level] %logger{36} - %msg%n&lt;/pattern&gt; &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--输出到文件 FileAppender--&gt; &lt;appender name=&quot;fileLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;!-- 日志名称，如果没有File 属性，那么只会使用FileNamePattern的文件路径规则 如果同时有&lt;File&gt;和&lt;FileNamePattern&gt;，那么当天日志是&lt;File&gt;，明天会自动把今天 的日志改名为今天的日期。即，&lt;File&gt; 的日志都是当天的。 --&gt; &lt;File&gt;${logdir}/${appname}.log&lt;/File&gt; &lt;!--滚动策略，按照时间滚动 TimeBasedRollingPolicy--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!--文件路径,定义了日志的切分方式——把每一天的日志归档到一个文件中,以防止日志填满整个磁盘空间--&gt; &lt;FileNamePattern&gt;${logdir}/${appname}.%d{yyyy-MM-dd}.log&lt;/FileNamePattern&gt; &lt;maxHistory&gt;${maxdays}&lt;/maxHistory&gt; &lt;totalSizeCap&gt;${maxsize}&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;!--日志输出编码格式化--&gt; &lt;encoder&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%-5level] %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 开发环境--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;/root&gt; &lt;!-- additivity是子Logger 是否继承 父Logger 的 输出源（appender） 的标志位 在这里additivity配置为false代表如果${basepackage}中有INFO级别日志则子looger打印 root不打印 --&gt; &lt;logger name=&quot;${basepackage}&quot; level=&quot;DEBUG&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;/logger&gt; &lt;/springProfile&gt; &lt;!-- 演示（测试）环境--&gt; &lt;springProfile name=&quot;test&quot;&gt; &lt;root level=&quot;WARN&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;appender-ref ref=&quot;fileLog&quot;/&gt; &lt;/root&gt; &lt;logger name=&quot;${basepackage}&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;appender-ref ref=&quot;fileLog&quot;/&gt; &lt;/logger&gt; &lt;/springProfile&gt; &lt;!-- 生产环境 --&gt; &lt;springProfile name=&quot;prod&quot;&gt; &lt;root level=&quot;ERROR&quot;&gt; &lt;appender-ref ref=&quot;consoleLog&quot;/&gt; &lt;appender-ref ref=&quot;fileLog&quot;/&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;/configuration&gt; &emsp;&emsp; 日志配置中引用了application.yml的配置信息，主要有logdir、appname、basepackage三项，logdir是日志文件的写入地址，可以传入相对路径，appname是应用名称，引入这项是为了通过日志文件名称区分是哪个应该输出的，basepackage是包过滤配置，比如开发环境中需要打印debug级别以上的日志，但是又想使除我写的logger之外的DEBUG不打印，可过滤到本项目的包名才用DEBUG打印，此外包名使用INFO级别打印，在application.yml中新建这三项配置，也可在不同环境配置不同属性 #应用配置 resources: # log文件写入地址 logdir: logs/ # 应用名称 appname: spring-boot-example # 日志打印的基础扫描包 basepackage: com.spring.demo.springbootexample &emsp;&emsp; 使用不同环境启动测试logger配置是否生效，在开发环境下将打印DEBUG级别以上的四条logger记录，在演示环境下降打印INFO级别以上的三条记录并写入文件，在生产环境下只打印ERROR级别以上的一条记录并写入文件 @RequestMapping(&quot;/logger&quot;) @ResponseBody public WebResult logger() { logger.trace(&quot;日志输出 {}&quot;, &quot;trace&quot;); logger.debug(&quot;日志输出 {}&quot;, &quot;debug&quot;); logger.info(&quot;日志输出 {}&quot;, &quot;info&quot;); logger.warn(&quot;日志输出 {}&quot;, &quot;warn&quot;); logger.error(&quot;日志输出 {}&quot;, &quot;error&quot;); return &quot;00&quot;; } 常用配置加载自定义配置@Component @PropertySource(value = {&quot;classpath:application.yml&quot;}, encoding = &quot;utf-8&quot;) public class Config { @Value(&quot;${resources.midpHost}&quot;) private String midpHost; public String getMidpHost() { return midpHost; } } 全局异常处理器@ControllerAdvice public class GlobalExceptionResolver { Logger logger = LoggerFactory.getLogger(GlobalExceptionResolver.class); @ExceptionHandler(value = Exception.class) @ResponseBody public WebResult exceptionHandle(HttpServletRequest req, Exception ex) { ex.printStackTrace(); logger.error(&quot;未知异常&quot;, ex); return WebResult.error(ERRORDetail.RC_0401001); } } 示例工程开源地址github","link":"/2018-02-21-build-springboot-env/"},{"title":"vue封装echarts组件","text":"将Echarts做一层小小的封装以满足使用需求 说明 做项目的时候为了让数据展示的更加直观，总会用到图表相关的控件，而说到图表控件第一时间当然想到ECharts这个开源项目，而它不像iview、element-ui这些组件使用起来那么便捷，需要绕一个小弯，为了图方便于是对ECharts进行了一层封装 控件演示 控件使用 概要 基于echarts的二次封装 由数据驱动 控件源码见src/components/charts 文档 props 属性 说明 类型 _id 图表唯一标识，当id重复将会报错 String _titleText 图表标题 String _xText x轴描述 String _yText y轴描述 String _chartData 图表数据 Array _type 图表类型，提供三种(LineAndBar/LineOrBar/Pie) String 调用示例 &lt;chart :_id=&quot;'testCharts'&quot; :_titleText=&quot;'访问量统计'&quot; :_xText=&quot;'类别'&quot; :_yText=&quot;'总访问量'&quot; :_chartData=&quot;chartData&quot; :_type=&quot;'Pie'&quot;&gt;&lt;/chart&gt; 实现方式 创建一个待渲染的dom&lt;template&gt; &lt;div :id=&quot;_id&quot; class=&quot;chart&quot;&gt;&lt;/div&gt; &lt;/template&gt; 绘制函数function drawPie(chartData,id,titleText,xText,yText) { var chart = echarts.init(document.getElementById(id)) var xAxisData = chartData.map(function (item) {return item[0]}) var pieData = [] chartData.forEach((v,i)=&gt;{ pieData.push({ name:v[0], value:v[1] }) }) chart.setOption({ title : { text: titleText, subtext: '', x:'center' }, tooltip : { trigger: 'item', formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot; }, legend: { orient: 'vertical', left: 'left', data: xAxisData }, series : [ { name: xText, type: 'pie', radius : '55%', center: ['50%', '60%'], data:pieData, itemStyle: { emphasis: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' } } } ] }) } 挂载结束、数据源改变时重绘 watch:{ _chartData(val){ switch (this._type){ case &quot;LineAndBar&quot;: drawLineAndBar(val,this._id,this._titleText,this._xText,this._yText); break case &quot;LineOrBar&quot;: drawLineOrBar(val,this._id,this._titleText,this._xText,this._yText); break case &quot;Pie&quot;: drawPie(val,this._id,this._titleText,this._xText,this._yText); break default: drawLineAndBar(val,this._id,this._titleText,this._xText,this._yText); break } } }, mounted() { switch (this._type){ case &quot;LineAndBar&quot;: drawLineAndBar(this._chartData,this._id,this._titleText,this._xText,this._yText); break case &quot;LineOrBar&quot;: drawLineOrBar(this._chartData,this._id,this._titleText,this._xText,this._yText); break case &quot;Pie&quot;: drawPie(this._chartData,this._id,this._titleText,this._xText,this._yText); break default: drawLineAndBar(this._chartData,this._id,this._titleText,this._xText,this._yText); break } } 如果觉得有用，欢迎star calebman/vue-DBM","link":"/2017-09-30-vue-echarts/"},{"title":"基于Element构建自定义树","text":"基于Element的render函数封装一个可以增、删、改的树形组件 说明 做项目的时候要使用到一个自定义的树形控件来构建表格树，在github上搜了一下没有搜索到合适的（好看的）可以直接用的，查看Element的组件说明时发现它的Tree控件可以使用render来自定义节点样式，于是基于它封装了一个可以增、删、改的树形组件，现在分享一下它的使用与实现。 控件演示 控件使用 概要 基于element-ui树形控件的二次封装 提供编辑、删除节点的接口 提供一个next钩子，在业务处理失败时可使用next(false)回滚操作 控件源码见 github 文档 props 属性 说明 类型 value 源数据，可使用v-model双向绑定 Array events 事件名 说明 参数 SaveEdit 点击编辑或者添加树节点后的保存事件 (父节点数据、当前节点数据、next) DelNode 删除节点事件 (父节点数据、当前节点数据、next) NodeClick 节点点击事件 (当前节点数据) 源数据描述 属性 说明 value 树节点的唯一标识 label 树节点的显示名称 status (1：编辑状态)(0：显示状态)(-1不可编辑状态) children 子节点数据 调用示例 &lt;m-tree v-model=&quot;tableTree&quot; @SaveEdit=&quot;SaveEdit&quot; @DelNode=&quot;DelNode&quot; @NodeClick=&quot;handleNodeClick&quot;&gt;&lt;/m-tree&gt; SaveEdit(parentNode,data,next){ var param = { parentNode:parentNode, node:data } this.$http.post(URL,param).then((response) =&gt; { if(response.status == 200){ next(true,response.body.data.nodeId) }else{ next(false) } }) } 实现方式 构建子节点的模板&lt;span class=&quot;span_item&quot;&gt; &lt;span @click=&quot;Expanded&quot;&gt; &lt;Input v-if=&quot;node.status == 1&quot; style=&quot;width: 100px;&quot; v-model=&quot;node.label&quot; size=&quot;small&quot; &gt;&lt;/Input&gt; &lt;Icon v-if=&quot;node.status == 0&quot; type=&quot;asterisk&quot;&gt;&lt;/Icon&gt; &lt;Icon v-if=&quot;node.status == -1&quot; type=&quot;ios-keypad-outline&quot;&gt;&lt;/Icon&gt; &lt;span v-if=&quot;node.status != 1&quot;&gt;{{node.label}}&lt;/span&gt; &lt;/span&gt; &lt;span v-if=&quot;node.status == 1&quot;&gt; &lt;Button style=&quot;margin-left: 8px;&quot; size=&quot;small&quot; type=&quot;success&quot; icon=&quot;checkmark-circled&quot; @click=&quot;SaveEdit&quot;&gt;确认&lt;/Button&gt; &lt;Button style=&quot;margin-left: 8px;&quot; size=&quot;small&quot; type=&quot;ghost&quot; icon=&quot;checkmark-circled&quot; @click=&quot;CancelEdit&quot;&gt;取消&lt;/Button&gt; &lt;/span&gt; &lt;span class=&quot;span_icon&quot;&gt; &lt;Icon v-if=&quot;node.status == 0&quot; style=&quot;margin-left: 8px&quot; color=&quot;gray&quot; type=&quot;edit&quot; size=&quot;16&quot; @click.native=&quot;OpenEdit&quot;&gt;&lt;/Icon&gt; &lt;Icon v-if=&quot;node.status == 0&quot; style=&quot;margin-left: 8px&quot; type=&quot;plus-round&quot; color=&quot;gray&quot; size=&quot;16&quot; @click.native=&quot;Append&quot;&gt;&lt;/Icon&gt; &lt;Icon v-if=&quot;node.status == 0&amp;&amp;node.children.length &lt; 1&quot; style=&quot;margin-left: 8px&quot; type=&quot;ios-trash&quot; color=&quot;red&quot; size=&quot;18&quot; @click.native=&quot;Delete&quot;&gt;&lt;/Icon&gt; &lt;/span&gt; &lt;/span&gt; 子节点通过$emit通知父节点事件SaveEdit(){ //保存节点事件 this.$emit('SaveEdit',this.nodeData) }, 父节点核心实现，使用renderContent函数加载子节点模板，点击保存节点时将业务参数保存在runParam中用于在业务操作失败（网络请求失败、服务端异常等情况）的数据回滚 &lt;el-tree class=&quot;filter-tree&quot; style=&quot;overflow:auto;&quot; :data=&quot;treeData&quot; :filter-node-method=&quot;filterNode&quot; @node-click=&quot;handleNodeClick&quot; ref=&quot;tree&quot; node-key=&quot;value&quot; :expand-on-click-node=&quot;false&quot; :render-content=&quot;renderContent&quot; default-expand-all&gt; &lt;/el-tree&gt; //子节点模板 renderContent(h, { node, data, store }) { return h(TreeItem,{ props:{ value:data, treeNode:node }, on:{ input:(node)=&gt;{ data = node }, Append: () =&gt; { node.expanded = true data.children.push({ value: this.$utilHelper.generateUUID(), label: '请输入模块名称', children: [],status:1,isAdd:true }) }, //保存节点 SaveEdit:(nodeData)=&gt; { //递归查找父节点 var parentNode = this.$utilHelper.getNode(this.treeData,data.value).parentNode this.runParam.parentNode = parentNode this.runParam.data = data this.runParam.nodeData = nodeData this.$emit('SaveEdit',parentNode,data,this.CanSaveNext) } } }) } 操作结果钩子，如果next函数传入false则判定操作失败，使用runParam中的参数进行回滚，该节点的编辑保存操作将无效 CanSaveNext(isNext,nodeId){ let parentNode = this.runParam.parentNode let nodeData = this.runParam.nodeData let data = this.runParam.data if(isNext){ parentNode.children.forEach((v,i)=&gt;{ if(v.value == data.value){ if(this.HOST != &quot;static&quot;&amp;&amp;data.isAdd){ data.value = nodeId } data.status = 0 parentNode.children.splice(i,1,data) } }) }else{ if(!data.isAdd){ parentNode.children.forEach((v,i)=&gt;{ if(v.value == nodeData.value){ data.label = nodeData.label parentNode.children.splice(i,1,data) } }) } } this.runParam = {} } 如果觉得有用，欢迎star calebman/vue-DBM","link":"/2017-09-19-vue-custom-tree/"}],"tags":[{"name":"vuejs","slug":"vuejs","link":"/tags/vuejs/"},{"name":"element-ui","slug":"element-ui","link":"/tags/element-ui/"},{"name":"echarts","slug":"echarts","link":"/tags/echarts/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"Netty","slug":"Netty","link":"/tags/Netty/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"maven","slug":"maven","link":"/tags/maven/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"devops","slug":"devops","link":"/tags/devops/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Dubbo","slug":"Dubbo","link":"/tags/Dubbo/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/tags/Machine-Learning/"},{"name":"Cache","slug":"Cache","link":"/tags/Cache/"},{"name":"Transaction","slug":"Transaction","link":"/tags/Transaction/"},{"name":"vuepress","slug":"vuepress","link":"/tags/vuepress/"},{"name":"plugin","slug":"plugin","link":"/tags/plugin/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"后端","slug":"后端","link":"/categories/后端/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"前后端分离","slug":"前后端分离","link":"/categories/前后端分离/"},{"name":"运维","slug":"运维","link":"/categories/运维/"},{"name":"测试","slug":"测试","link":"/categories/测试/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"}]}