

<!DOCTYPE html>
<html lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <title>Vite + Vue3.0 + SpringBoot 实践 [ Sincerity ]</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="icon" href="/images/favicon-32x32.png">
  
  <!-- stylesheets list from _config.yml -->
  
  <link rel="stylesheet" href="/css/simple.css">
  
  <link rel="stylesheet" href="/css/font.css">
  
  
</head>

<body>

  <header class="header">
    <nav class="nav">
      <a href="/" class="nav-logo"><img src="/images/avatar.png" width="50" height="50" alt="Logo"></a>
      <ul class="nav-links">
        
        <li><a href="/">文章</a></li>
        
        <li><a href="/archives">归档</a></li>
        
        <li><a href="/leetcode">力扣</a></li>
        
        <li><a href="/about">关于我</a></li>
        
        <li><a href="https://github.com/calebman">Github</a></li>
        
      </ul>
    </nav>
  </header>

  <main class="content">
    
<article class="article">
  <h1 class="article-title">Vite + Vue3.0 + SpringBoot 实践</h1>
  <span class="article-date">2021-06-16</span>
  
  
  <a class="article-tag" href="/tags/SpringBoot">
    SpringBoot
  </a>
  
  <a class="article-tag" href="/tags/Vue">
    Vue
  </a>
  
  <a class="article-tag" href="/tags/Vite">
    Vite
  </a>
  
  

  <div><p>  </p>
<h1>工具集介绍</h1>
<p>实践开始之前先一起来了解下我们即将要使用到的工具集，SpringBoot 就不再多说了，下面将会花费多一些的篇幅来讲解一下 Vite 与 Vue3.0 给我们带来的惊喜。</p>
<blockquote>
<p>之所以把 Vite 放到 Vue3.0 之前讲，是因为 Vite 的关注点更具有“独特性”，如何来理解这句话，我们先看下 Vite 与 Vue3.0 的关注点：</p>
<p>Vue3.0 关注性能提升与更具逻辑组合性的 API，这是个热点问题，属于开发者的刚需。<br>
Vite 关注如何提升开发环境的体验，这是个较为冷门且吃力的问题，可以对比 webpack 的热重载，在模块较多的情况下，改一下代码需要等待的时间是秒级别的，多年来也没有太多优化的办法。</p>
</blockquote>
<h2 id="Vite">Vite</h2>
<p>Vite is an opinionated web dev build tool that serves your code via native ES Module imports during dev and bundles it with Rollup for production.</p>
<p>Vite 是一个基于浏览器原生 ES Module 的开发服务器，生产模式使用 Rollup 打包。</p>
<blockquote>
<p>Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，其官方文档<a href="https://www.rollupjs.com/guide/introduction/" target="_blank" rel="noopener">点此访问</a></p>
</blockquote>
<p>Vite 第一次暴露在公众视野是尤雨溪在B站直播中提到了，<a href="https://www.bilibili.com/s/video/BV1Hg4y1z7xW" target="_blank" rel="noopener">录播视频点此访问</a>，后来在<a href="https://www.bilibili.com/video/BV1qC4y18721" target="_blank" rel="noopener">前端会客厅</a>这个节目中主持人和尤雨溪深入讨论了一下 Vite 的应用场景与实现原理。</p>
<blockquote>
<p>在了解 Vite 前我们先思考以下几个问题，通过阅读本章节的内容这些问题都能迎刃而解：</p>
<ol>
<li>Vite 解决了什么问题？没有 Vite 之前的世界是怎样的？</li>
<li>浏览器原生 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">ES Module</a> 是什么？</li>
<li>我们该如何使用 Vite？</li>
</ol>
</blockquote>
<h3 id="Vite-解决了什么问题？">Vite 解决了什么问题？</h3>
<p>Vite 主要解决前端工程化的项目在达到一定规模后，开发环境代码热重载的效率问题，Vite 借助浏览器原生的 ES Module 可以做到以下几个事情：</p>
<ol>
<li>冷启动：项目启动时不需要加载、编译所有的模块代码，理论上能做到不管多大的项目都能有一个均衡、极速的启动时间；</li>
<li>按需编译：Vite 会根据浏览器的请求仅编译其所需的源文件，配合 LRUCache 可以再次提升性能。</li>
<li>高效的热更新：每个 Vue 文件都会有一个唯一 ID，开发者修改完单 Vue 文件的代码后，借助 WebSocket 与 vue.HMRRuntime 处理或者重新加载新的资源。</li>
</ol>
<p><strong>那没有 Vite 之前的世界是怎样的？</strong></p>
<p>在没有 Vite 之前我们一般会选择 Vue Cli 作为 Vue 应用的开发脚手架，Vue Cli 的热更新基于监听，代码发生变化时重新编译，配合缓存来实现较高的性能。</p>
<h3 id="Vite-依赖的-ES-Module-是什么？">Vite 依赖的 ES Module 是什么？</h3>
<p>ES Module 简称 ESM，是 ES6 标准中的模块化语法，使用过 Vue.js 的同学应该很熟悉下面的语法：</p>
<pre><code class="language-js">// router.js
const routes = []
export default routes

// utils.js
function debug() {
  if (process.env.NODE_ENV === 'development') {
    console.log.apply(null, arguments)
  }
}
export {
  debug
}

// main.js
import _ from 'lodash'
import { debug } from './utils'
import routes from './routes'
// xxxx
</code></pre>
<p>上述代码能够被 Node.js 编译运行，那类似的语法能不能直接在浏览器运行呢？答案自然是可以的，浏览器已经开始实施这个标准，到现在 Chrome，Safari，Edge 和 Firefox（从 60 版本开始）都支持ESM 模块。</p>
<ul>
<li>
<p>那么在浏览器怎么使用 ESM 呢？主要分为以下两步：</p>
<ol>
<li>通过 HTML 标签的方式指定以 <code>module</code> 方式加载脚本；</li>
</ol>
<pre><code class="language-html">&lt;script type=&quot;module&quot; src=&quot;utils.js&quot;&gt;&lt;/script&gt;
</code></pre>
<ol start="2">
<li>以 <code>module</code> 方式加载的脚本可直接使用 ESM 语法；</li>
</ol>
<pre><code class="language-js">import { debug } from './utils'
</code></pre>
</li>
<li>
<p>ESM 语法实践：</p>
<p>通过以下脚本能够获取到示例代码包，<a href="#ESM-%E5%AE%9E%E8%B7%B5%E4%BB%A3%E7%A0%81">示例源码点此访问</a></p>
<p>下方使用到库 anywhere，它是一个能够随时随地将你的当前目录变成一个静态文件服务器的根目录的工具，仓库介绍<a href="https://www.npmjs.com/package/anywhere" target="_blank" rel="noopener">点此访问</a>。</p>
<pre><code class="language-sh">$ wget https://resources.chenjianhui.site/esm-demo.zip
$ unzip esm-demo.zip
$ cd esm-demo &amp;&amp; tree
.
├── index.html
├── index.js
└── utils.js
$ yarn global add anywhere
$ anywhere
</code></pre>
</li>
<li>
<p>使用 ESM 中常见的问题：</p>
<ol>
<li>
<p>Uncaught SyntaxError: Cannot use import statement outside a module.<br>
使用 ESM 语法的脚本需要使用 <code>type</code> 为 <code>module</code> 的标签引入。</p>
</li>
<li>
<p>Uncaught TypeError: Failed to resolve module specifier “utils”. Relative references must start with either “/”, “./”, or “…/”.<br>
使用 ESM 语法引入的包必须以 <code>/</code>，<code>./</code>，<code>../</code> 开头。</p>
</li>
</ol>
</li>
</ul>
<h3 id="我们该如何使用-Vite？">我们该如何使用 Vite？</h3>
<pre><code class="language-bash">$ yarn create vite-app &lt;project-name&gt;
$ cd &lt;project-name&gt;
$ yarn
$ yarn dev
</code></pre>
<h1>参考资料</h1>
<ul>
<li><a href="https://juejin.im/post/5ed9d652f265da76fa4b6b2d" target="_blank" rel="noopener">vite —— 一种新的、更快地 web 开发工具 - 掘金</a></li>
<li><a href="https://z.itpub.net/dynamicdetail/69975286/17AAE12DC329E3E21D64A1DCF01DB0B0" target="_blank" rel="noopener">是什么尤大选择放弃Webpack？——vite 原理解析 - 小栈文章详情</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/149033579" target="_blank" rel="noopener">前端新工具–vite从入门到实战（一） - 知乎</a></li>
<li><a href="https://segmentfault.com/a/1190000014318751" target="_blank" rel="noopener">图说 ES Modules - 个人文章 - SegmentFault 思否</a></li>
</ul>
<h1>附录</h1>
<h2 id="ESM-实践代码">ESM 实践代码</h2>
<ol>
<li>index.html</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;ESM Demo&lt;/title&gt;
&lt;/head&gt;
&lt;script type=&quot;module&quot; src=&quot;index.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<ol start="2">
<li>index.js</li>
</ol>
<pre><code class="language-js">import { debug } from './utils.js'
debug('ESM demo test.')
</code></pre>
<ol start="3">
<li>utils.js</li>
</ol>
<pre><code class="language-js">function debug() {
  console.log.apply(null, arguments)
}
export {
  debug
}
</code></pre>
</div>

  
  <div>
    <h1>推荐阅读</h1>
    <ul>
      
      <li><a href="/2020-05-31-vuepress-plugin-demo-container/"> 使用 Vuepress 编写组件示例文档的最佳实践</a></li>
      
      <li><a href="/2018-05-18-vue-notes/"> 纯正后端的vue轮子笔记</a></li>
      
      <li><a href="/2017-09-30-vue-echarts/"> vue封装echarts组件</a></li>
      
      <li><a href="/2017-09-19-vue-custom-tree/"> 基于Element构建自定义树</a></li>
      
    </ul>
  </div>
  

</article>
<ul class="post-copyright">
  <li><strong>本文标题：</strong><a href="https://chenjianhui.site/2021-06-16-vite-springboot/">Vite + Vue3.0 + SpringBoot 实践</a></li>
  <li><strong>本文作者：</strong><a href="https://chenjianhui.site">JianhuiChen</a></li>
  <li><strong>本文链接：</strong><a href="https://chenjianhui.site/2021-06-16-vite-springboot/">https://chenjianhui.site/2021-06-16-vite-springboot/</a></li>
  <li><strong>发布时间：</strong>2021-06-16</li>
  <li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>
<div id="gitalk-container"></div>

<!-- Gittalk.js -->
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<!-- Highlight.js -->
<link rel="stylesheet" href="/css/hljs.css">
<script src="/js/highlight.min.js"></script>
<script>
  hljs.initHighlightingOnLoad();
  const gitalk = new Gitalk({
    clientID: 'bd0cbb30da9c24da8c7c',
    clientSecret: 'bd64a8e8c8117d5f3e22291cd3f29f2c70e671ff',
    repo: 'blog',
    owner: 'calebman',
    admin: ['calebman']
  })
  gitalk.render('gitalk-container')
</script>
  </main>

  <footer class="footer">
    <ul class="footer-links">
      <section class="copyright">
        <a href="https://chenjianhui.site">JianhuiChen</a> © 2017 - 2020 | 
        <a href="http://beian.miit.gov.cn" style="line-height: 37px;font-size: 16px;">津ICP备19001724号</a>
      </section>
    </ul>
  </footer>

  
  <!-- scripts list from theme config.yml -->
  
  <script src="/js/simple.js"></script>
  
  

</body>

</html>